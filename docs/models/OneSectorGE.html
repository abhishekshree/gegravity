<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>models.OneSectorGE API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>models.OneSectorGE</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">__Author__ = &#34;Peter Herman&#34;
__Project__ = &#34;Gravity Code&#34;
__Created__ = &#34;08/15/2018&#34;
__all__ = [&#39;OneSectorGE&#39;, &#39;ParameterValues&#39;, &#39;Country&#39;, &#39;Economy&#39;,&#39;ResultsLabels&#39;]
__Description__ = &#34;&#34;&#34;A single sector or aggregate full GE model based on Larch and Yotov, &#39;General Equilibrium Trade
                  Policy Analysis with Structural Gravity,&#34; 2016. (WTO Working Paper ERSD-2016-08)&#34;&#34;&#34;

# ToDo: Finish OneSectorGE attributes list, add attributes for Country and Economy classes.

from typing import List
import numpy as np
import pandas as pd
from pandas import DataFrame
from gme.estimate.EstimationModel import EstimationModel
from scipy.optimize import root
from numpy import multiply, median
from warnings import warn
import math as math
from models.ResultsLabels import ResultsLabels


&#39;&#39;&#39;
Convergence Tips:
    1. Modify the omr_rescale factor. Examining the estimates for different countries from non-convergent simulations 
        can help inform the correct rescale factor. Function values close to 1 seem to suggest MR initial values that 
        are too small. OMR rescaling will likely work better as IMR for the reference importer equals 1 by definition.
    2. Ensure data is square otherwise necessary fields end up empty (e.g. can&#39;t construct all necessary trade costs)
&#39;&#39;&#39;

class OneSectorGE(object):
    def __init__(self,
                 estimation_model: EstimationModel,
                 year: str,
                 reference_importer: str,
                 expend_var_name: str = &#39;expenditure&#39;,
                 output_var_name: str = &#39;output&#39;,
                 sigma: float = 5,
                 results_key: str = &#39;all&#39;,
                 cost_variables: List[str] = None,
                 parameter_values = None,
                 #approach: str = None,
                 quiet:bool = False):
        &#39;&#39;&#39;
        Define a general equilibrium (GE) gravity model.
        Args:
            estimation_model (gme.EstimationModel): A GME Estimation model
            year (str): The year to be used for the model. Works best if estimation_model year column has been cast as
                string too.
            reference_importer (str): Identifier for the country to be used as the reference importer (inward
                multilateral resistance normalized to 1 and other multilateral resistances solved relative to it).
            expend_var_name (str): Column name of variable containing expenditure data in estimation_model.
            output_var_name (str): Column name of variable containing output data in estimation_model.
            sigma (float): Elasticity of substitution.
            results_key (str): (optional) If using parameter estimates from estimation_model, this is the key (i.e.
                sector) corresponding to the estimates to be used. For single sector estimations (sector_by_sector =
                False in GME model), this key is &#39;all&#39;, which is the default.
            cost_variables (List[str]): (optional) A list of variables to use to compute bilateral trade costs. By
                default, all included non-fixed effect variables are used.
            parameter_values (ParameterValues): (optional) A set of parameter values or estimates to use for constructing
                trade costs. Should be of type gegravity.ParameterValues, statsmodels.GLMResultsWrapper, or
                gme.SlimResults. If no values are provided, the estimates in the EstimationModel are used.
            quiet (bool): (optional) If True, suppresses all console feedback from model during simulation. Default is False.

        Attributes:
            aggregate_trade_results (pandas.DataFrame): Country-level, aggregate results. See models.ResultsLabels for
                column details.
            baseline_trade_costs (pandas.DataFrame): The constructed baseline trade costs for each bilateral pair
                (t_{ij}^{1-sigma}). Calculated as exp{sum_k (B^k*x^k_ij)} for all cost variables x^k and estimate
                values B.
            bilateral_trade_results (pandas.DataFrame): Bilateral trade results. See models.ResultsLabels for
                column details.
            country_mr_terms (pandas.DataFrame): Baseline and counterfactual inward and outward multilateral resistance
                estimates. See models.ResultsLabels for column details.
            country_results (pandas.DataFrame): A collection of the main country-level simulation results. See
                models.ResultsLabels for column details.
            country_set (dict[Country]): A dictionary containing a Country object for each country in the model, keyed
                by their respective identifiers.
            cost_shock (pandas.DataFrame): The baseline and experiment trade costs combined.
            economy (Economy): The model&#39;s Economy object.
            experiment_data (pandas.DataFrame): The counterfactual experiment data.
            experiment_trade_costs (pandas.DataFrame): The constructed experiment trade costs for each bilateral pair
                (t_{ij}^{1-sigma}). Calculated as exp{sum_k (B^k*x^k_ij)} for all cost variables x^k and estimate
                values B
            factory_gate_prices (pandas.DataFrame): Counterfactual prices (baseline prices are all normalized to 1).
            outputs_expenditures (pandas.DataFrame): Baseline and counterfactual expenditure and output values. See
                models.ResultsLabels for column details.
            sigma (int): The elasticity of substitution parameter value
            solver_diagnostics (dict): A dictionary of solver diagnostics for the three solution routines: baseline
                multilateral resistances, conditional multilateral resistances (partial equilibrium counterfactual
                effects) and the full GE model. Each element contains a dictionary of various diagnostic info from
                scipy.optimize.root.

        Examples:

        &#39;&#39;&#39;
        # &#39;&#39;&#39;
        #
        # # ---
        # # Methods
        # # ---
        #
        # ##
        # # Model Construction and Simulation
        # ##
        #
        # build_baseline(omr_rescale: float = 1, imr_rescale: float = 1,  mr_method: str = &#39;hybr&#39;,
        #                mr_max_iter: int = 1400, mr_tolerance: float = 1e-8)
        #     Solve the baseline model. This primarily solves for the baseline Multilateral Resistance (MR) terms.
        #
        # define_experiment(experiment_data: DataFrame = None)
        #     Specify the counterfactual data to use for experiment.
        #
        # simulate(ge_method: str = &#39;hybr&#39;, ge_tolerance: float = 1e-8, ge_max_iter: int = 1000)
        #     Simulate the counterfactual scenario.
        #
        # ##
        # # Post-simulation Analysis
        # ##
        #
        # trade_share(importers: List[str], exporters: List[str])
        #     Calculate baseline and experiment import and export shares (in percentages) between user-supplied countries.
        #
        # export_results(directory:str = None, name:str = &#39;&#39;)
        #     Export results to csv files. Three files are stored containing (1) country-level results, (2) bilateral
        #     results, and (3) solver diagnostics.
        #
        # calculate_levels(how: str = &#39;country&#39;):
        #     Calculate changes in the level (value) of trade using baseline trade values and simulation outcomes. Results
        #     can be calculated at either the country level or bilateral level.
        #
        # ##
        # # Trouble-shooting
        # ##
        #
        # test_baseline_mr_function(inputs_only:bool=False)
        #     Test whether the multilateral resistance system of equations can be computed from baseline data. Helpful for
        #     debugging initial data problems. Note that the returned function values reflect those generated by the
        #     initial values and do not reflect a solution to the system.
        #
        # check_omr_rescale(omr_rescale_range:int = 10, mr_method: str = &#39;hybr&#39;, mr_max_iter: int = 1400,
        #                  mr_tolerance: float = 1e-8, countries:List[str] = [])
        #     Analyze different Outward Multilarteral Resistance (OMR) term rescale factors. This method can help identify
        #     feasible values to use for the omr_rescale argument in OneSectorGE.build_baseline().
        # &#39;&#39;&#39;
        if not isinstance(year, str):
            raise TypeError(&#39;year should be a string&#39;)

        # Check reference country (does not currently work)
        # try:
        #     omitted_fe = estimation_model.results_dict[results_key].params[(&#39;importer_fe_&#39;+reference_importer)]
        #     raise ValueError(&#39;reference_importer should be the excluded importer fixed effect&#39;)
        # except:
        #     print(&#39;reference_importer OK&#39;)
        self.labels = ResultsLabels()
        self.meta_data = _GEMetaData(estimation_model.estimation_data._meta_data, expend_var_name, output_var_name)
        self._estimation_model = estimation_model
        if parameter_values is None:
            self._estimation_results = self._estimation_model.results_dict[results_key]
        else:
            self._estimation_results = None
        self._year = str(year)
        self.sigma = sigma
        self._reference_importer = reference_importer
        self._omr_rescale = None
        self._imr_rescale = None
        self._mr_max_iter = None
        self._mr_tolerance = None
        self._mr_method = None
        self._ge_method = None
        self._ge_tolerance = None
        self._ge_max_iter = None
        self.country_set = None
        self.economy = None
        self.baseline_trade_costs = None # t_{ij}^{1-sigma}
        self.experiment_trade_costs = None # t_{ij}^{1-sigma}
        self.cost_shock = None
        self.experiment_data = None
        self.approach = None # Disabled until GEPPML is completed
        self.quiet = quiet

        # Results fields
        self.bilateral_trade_results = None
        self.aggregate_trade_results = None
        self.solver_diagnostics = dict()
        self.factory_gate_prices = None
        self.outputs_expenditures = None
        self.country_results = None
        self.country_mr_terms = None

        # Status checks
        self._baseline_built = False
        self._experiment_defined = False


        # ---
        # Check inputs
        # ---
        if self.meta_data.trade_var_name is None:
            raise ValueError(&#39;\n Missing Input: Please insure trade_var_name is set in EstimationData object.&#39;)

        if cost_variables is None:
            self.cost_variables = self._estimation_model.specification.rhs_var
        else:
            self.cost_variables = cost_variables

        if parameter_values is not None:
            self.cost_coeffs = parameter_values.params
        else:
            self.cost_coeffs = self._estimation_results.params[self.cost_variables]


        # prep baseline data
        _baseline_data = estimation_model.estimation_data.data_frame.copy()
        _baseline_data[self.meta_data.year_var_name] = _baseline_data[self.meta_data.year_var_name].astype(str)
        self.baseline_data = _baseline_data.loc[_baseline_data[self.meta_data.year_var_name] == self._year, :].copy()
        if self.baseline_data.shape[0] == 0:
            raise ValueError(&#34;There are no observations corresponding to the supplied &#39;year&#39;&#34;)


        # Initialize a set of countries and the economy
        self.country_set = self._create_baseline_countries()
        self.economy = self._create_baseline_economy()
        # Calculate certain country values using info from the whole economy
        for country in self.country_set:
            self.country_set[country]._calculate_baseline_output_expenditure_shares(self.economy)
        # Calculate baseline trade costs
        self.baseline_trade_costs = self._create_trade_costs(self.baseline_data)




    def build_baseline(self,
                       omr_rescale: float = 1,
                       imr_rescale: float = 1,
                       mr_method: str = &#39;hybr&#39;,
                       mr_max_iter: int = 1400,
                       mr_tolerance: float = 1e-8):
        &#39;&#39;&#39;
        Solve the baseline model. This primarily solves for the baseline Multilateral Resistance (MR) terms.
        Args:
            omr_rescale (int): (optional) This value rescales the OMR values to assist in convergence. Often, OMR values
                are orders of magnitude different than IMR values, which can make convergence difficult. Scaling by a
                different order of magnitude can help. Values should be of the form 10^n. By default, this value is 1
                (10^0). However, users should be careful with this choice as results, even when convergent, may not be
                fully robust to any selection. The method OneSectorGE.check_omr_rescale() can help identify and compare
                feasible values.
            imr_rescale (int): (optional) This value rescales the IMR values to potentially aid in conversion. However,
                because the IMR for the reference importer is normalized to one, it is unlikely that there will be because
                because changing the default value, which is 1.
            mr_method (str): This parameter determines the type of non-linear solver used for solving the baseline and
                experiment MR terms. See the documentation for scipy.optimize.root for alternative methods. the default
                value is &#39;hybr&#39;.
            mr_max_iter (int): (optional) This parameter sets the maximum limit on the number of iterations conducted
                by the solver used to solve for MR terms. The default value is 1400.
            mr_tolerance (float): (optional) This parameterset the convergence tolerance level for the solver used to
                solve for MR terms. The default value is 1e-8.

        Returns:
            None: Populates Attributes of model object.
        &#39;&#39;&#39;
        self._omr_rescale = omr_rescale
        self._imr_rescale = imr_rescale
        self._mr_max_iter = mr_max_iter
        self._mr_tolerance = mr_tolerance
        self._mr_method = mr_method

        # Solve for the baseline multilateral resistance terms
        if self.approach == &#39;GEPPML&#39;:
            if self._estimation_results is None:
                raise ValueError(&#34;GEPPML approach requires that the gme.EstimationModel be estimated and use importer and exporter fixed effects.&#34;)
            self._calculate_GEPPML_multilateral_resistance(version=&#39;baseline&#39;)
        else:
            self._calculate_multilateral_resistance(trade_costs=self.baseline_trade_costs, version=&#39;baseline&#39;)
        # Calculate baseline factory gate prices
        self._calculate_baseline_factory_gate_params()
        self._baseline_built = True

        # ToDo: run some checks the ensure the baseline is solved (e.g. the betas solve the factory gat price equations)

    def _create_baseline_countries(self):
        &#34;&#34;&#34;
        Initialize set of country objects
        &#34;&#34;&#34;
        # Requires that the baseline data has output and expenditure data

        # Make sure the year data is in string form
        self.baseline_data[self.meta_data.year_var_name] = self.baseline_data.loc[:,
                                                           self.meta_data.year_var_name].astype(str)

        # Create Country-level observations
        year_data = self.baseline_data.loc[self.baseline_data[self.meta_data.year_var_name] == self._year, :]

        importer_info = year_data[[self.meta_data.imp_var_name, self.meta_data.expend_var_name]].copy()

        importer_info = importer_info.groupby([self.meta_data.imp_var_name])
        expenditures = importer_info.mean().reset_index()

        exporter_info = year_data[[self.meta_data.exp_var_name, self.meta_data.output_var_name]].copy()
        exporter_info = exporter_info.groupby([self.meta_data.exp_var_name])
        output = exporter_info.mean().reset_index()

        country_data = pd.merge(left=expenditures,
                                right=output,
                                how=&#39;outer&#39;,
                                left_on=[self.meta_data.imp_var_name],
                                right_on=[self.meta_data.exp_var_name])

        reference_expenditure = float(
            country_data.loc[country_data[self.meta_data.imp_var_name] == self._reference_importer,
                             self.meta_data.expend_var_name])

        # Convert DataFrame to a dictionary of country objects
        country_set = {}

        # Identify appropriate fixed effect naming convention and define function for creating them
        fe_specification = self._estimation_model.specification.fixed_effects
        # Importer FEs
        if [self.meta_data.imp_var_name] in fe_specification:
            def imp_fe_identifier(country_id):
                return &#34;_&#34;.join([self.meta_data.imp_var_name,
                                 &#39;fe&#39;, (country_id)])
        elif [self.meta_data.imp_var_name, self.meta_data.year_var_name] in fe_specification:
            def imp_fe_identifier(country_id):
                return &#34;_&#34;.join([self.meta_data.imp_var_name, self.meta_data.year_var_name,
                                 &#39;fe&#39;, (country_id + self._year)])
        else:
            raise ValueError(&#34;Fixed Effect Specification must feature {} or {}&#34;.format([self.meta_data.imp_var_name],
                                                                                       [self.meta_data.imp_var_name,
                                                                                        self.meta_data.year_var_name]))

        # Exporter FEs
        if [self.meta_data.exp_var_name] in fe_specification:
            def exp_fe_identifier(country_id):
                return &#34;_&#34;.join([self.meta_data.exp_var_name,
                                 &#39;fe&#39;, (country_id)])
        elif [self.meta_data.imp_var_name, self.meta_data.year_var_name] in fe_specification:
            def exp_fe_identifier(country_id):
                return &#34;_&#34;.join([self.meta_data.exp_var_name, self.meta_data.year_var_name,
                                 &#39;fe&#39;, (country_id + self._year)])
        else:
            raise ValueError(
                &#34;Fixed Effect Specification must feature {} or {}&#34;.format([self.meta_data.exp_var_name],
                                                                          [self.meta_data.exp_var_name,
                                                                           self.meta_data.year_var_name]))

        for row in range(country_data.shape[0]):
            country_id = country_data.loc[row, self.meta_data.imp_var_name]

            # Get fixed effects if estimated
            try:
                bsln_imp_fe = self._estimation_results.params[imp_fe_identifier(country_id)]
            except:
                bsln_imp_fe = &#39;no estimate&#39;
            try:
                bsln_exp_fe = self._estimation_results.params[exp_fe_identifier(country_id)]
            except:
                bsln_exp_fe = &#39;no estimate&#39;

            # Build country
            try:
                country_ob = Country(identifier=country_id,
                                     year=self._year,
                                     baseline_output=country_data.loc[row, self.meta_data.output_var_name],
                                     baseline_expenditure=country_data.loc[row, self.meta_data.expend_var_name],
                                     baseline_importer_fe=bsln_imp_fe,
                                     baseline_exporter_fe=bsln_exp_fe,
                                     reference_expenditure=reference_expenditure)
            except:
                raise ValueError(
                    &#34;Missing baseline information for {}. Check that there are output and expenditure data.&#34;.format(
                        country_id))

            country_set[country_ob.identifier] = country_ob

        return country_set

    def _create_baseline_economy(self):
        # Initialize Economy
        economy = Economy(sigma=self.sigma)
        economy._initialize_baseline_total_output_expend(self.country_set)
        return economy

    def _create_trade_costs(self,
                            data_set: object = None):
        &#39;&#39;&#39;
        Create bilateral trade costs. Returned values reflect \hat{t}^{1-\sigma}_{ij}, not \hat{t}. See equation (32)
        from Larch and Yotov (2016) &#34;GENERAL EQUILIBRIUM TRADE POLICY ANALYSIS WITH STRUCTURAL GRAVITY&#34;
        :param data_set: (DataFrame) The trade cost data to base trade costs on (either baseline or experimental)
        :return: (DataFrame) DataFrame of bilateral trade costs (t^{1-sigma})
        &#39;&#39;&#39;
        obs_id = [self.meta_data.imp_var_name,
                  self.meta_data.exp_var_name,
                  self.meta_data.year_var_name]
        weighted_costs = data_set[obs_id + self.cost_variables].copy()
        weighted_list = []
        # Cumulatively add each variable in the list of cost variables.
        for variable in self.cost_variables:
            weighted_costs[(&#39;cost_weighted_&#39; + variable)] = self.cost_coeffs[variable] * \
                                                            weighted_costs[[variable]]
            weighted_list = weighted_list + [(&#39;cost_weighted_&#39; + variable)]
        # Generate cost measure t^{1-sigma}
        weighted_costs[&#39;trade_cost&#39;] = np.exp(weighted_costs[weighted_list].sum(axis=1))
        # Run some checks for completeness
        if weighted_costs.isna().any().any():
            warn(&#34;\n Calculated trade costs contain missing (nan) values. Check parameter values and trade cost variables in baseline or experiment data.&#34;)
        if weighted_costs.shape[0] != len(self.country_set.keys())**2:
            warn(&#34;\n Calculated trade costs are not square. Some bilateral costs are absent.&#34;)
        return weighted_costs[obs_id + [&#39;trade_cost&#39;]]

    def _create_cost_output_expend_params(self, trade_costs):
        # Prepare cost/expenditure and cost/output parameters
        # cost_output_share: t_{ij}^{1-\sigma} * Y_i / Y
        # cost_expend_share: t_{ij}^{1-\sigma} * E_j / Y
        cost_params = trade_costs.copy()
        cost_params[&#39;cost_output_share&#39;] = -9999
        cost_params[&#39;cost_expend_share&#39;] = -9999
        # Build actual values
        for row in cost_params.index:
            importer_key = cost_params.loc[row, self.meta_data.imp_var_name]
            exporter_key = cost_params.loc[row, self.meta_data.exp_var_name]
            cost_params.loc[row, &#39;cost_output_share&#39;] = cost_params.loc[row, &#39;trade_cost&#39;] \
                                                        * self.country_set[exporter_key].baseline_output_share
            cost_params.loc[row, &#39;cost_expend_share&#39;] = cost_params.loc[row, &#39;trade_cost&#39;] \
                                                        * self.country_set[importer_key].baseline_expenditure_share
        cost_params.sort_values([self.meta_data.exp_var_name, self.meta_data.imp_var_name], inplace=True)
        # Reshape to a Matrix with exporters as rows, importers as columns
        cost_exp_shr = cost_params.pivot(index=self.meta_data.exp_var_name,
                                         columns=self.meta_data.imp_var_name,
                                         values=&#39;cost_expend_share&#39;)
        cost_out_shr = cost_params.pivot(index=self.meta_data.exp_var_name,
                                         columns=self.meta_data.imp_var_name,
                                         values=&#39;cost_output_share&#39;)
        if np.isnan(cost_exp_shr.values).any():
            warn(&#34;\n &#39;cost_exp_share&#39; values contain missing (nan) values. \n 1. Check that expenditure shares exist for all countries in country_set \n 2. Check that trade cost data is square and no bilateral pairs are missing.&#34;)
        if np.isnan(cost_out_shr.values).any():
            warn(&#34;\n &#39;cost_out_share&#39; values contain missing (nan) values. \n 1. Check that output shares exist for all countries in country_set \n 2. Check that trade cost data is square no bilateral pairs are missing.&#34;)

        # Convert to numpy array to improve solver speed
        built_params = dict()
        built_params[&#39;cost_exp_shr&#39;] = cost_exp_shr.values
        built_params[&#39;cost_out_shr&#39;] = cost_out_shr.values


        return built_params

    def _calculate_multilateral_resistance(self,
                                           trade_costs: DataFrame,
                                           version: str,
                                           test=False,
                                           inputs_only=False):
        # Step 1: Build parameters for solver
        mr_params = dict()
        country_list = list(self.country_set.keys())
        mr_params[&#39;number_of_countries&#39;] = len(country_list)
        mr_params[&#39;omr_rescale&#39;] = self._omr_rescale
        mr_params[&#39;imr_rescale&#39;] = self._imr_rescale
        # Calculate parameters reflecting trade costs, output shares, and expenditure shares
        cost_shr_params = self._create_cost_output_expend_params(trade_costs=trade_costs)
        # cost_output_share: t_{ij}^{1-\sigma} * Y_i / Y
        # cost_expend_share: t_{ij}^{1-\sigma} * E_j / Y
        mr_params[&#39;cost_exp_shr&#39;] = cost_shr_params[&#39;cost_exp_shr&#39;]
        mr_params[&#39;cost_out_shr&#39;] = cost_shr_params[&#39;cost_out_shr&#39;]

        # Step 2: Solve
        initial_values = [1] * (2 * mr_params[&#39;number_of_countries&#39;] - 1)
        if test:
            # Option for testing and diagnosing the MR function
            test_diagnostics = dict()
            test_diagnostics[&#39;initial values&#39;] = initial_values
            test_diagnostics[&#39;mr_params&#39;] = mr_params
            if inputs_only:
                return test_diagnostics
            else:
                test_diagnostics[&#39;function_value&#39;] = &#39;unsolved&#39;
                test_diagnostics[&#39;function_value&#39;] = _multilateral_resistances(initial_values, mr_params)
                return test_diagnostics
        # Actual Solver
        else:
            if not self.quiet:
                print(&#39;Solving for {} MRs...&#39;.format(version))
            solved_mrs = root(_multilateral_resistances, initial_values, args=mr_params, method=self._mr_method,
                              tol=self._mr_tolerance,
                              options={&#39;xtol&#39;: self._mr_tolerance, &#39;maxfev&#39;: self._mr_max_iter})
            if solved_mrs.message == &#39;The solution converged.&#39;:
                if not self.quiet:
                    print(solved_mrs.message)
            else:
                warn(solved_mrs.message)
            self.solver_diagnostics[version + &#34;_MRs&#34;] = solved_mrs

            # Step 3: Pack up results
            country_list.sort()
            imrs = solved_mrs.x[0:len(country_list) - 1] * mr_params[&#39;imr_rescale&#39;]
            imrs = np.append(imrs, 1)
            omrs = solved_mrs.x[len(country_list) - 1:] * mr_params[&#39;omr_rescale&#39;]
            mrs = pd.DataFrame(data={&#39;imrs&#39;: imrs, &#39;omrs&#39;: omrs}, index=country_list)

            if version == &#39;baseline&#39;:
                for country in country_list:
                    self.country_set[country]._baseline_imr_ratio = mrs.loc[country, &#39;imrs&#39;]  # 1 / P^{1-sigma}
                    self.country_set[country]._baseline_omr_ratio = mrs.loc[country, &#39;omrs&#39;]  # 1 / π^{1-sigma}

            if version == &#39;conditional&#39;:
                for country in country_list:
                    self.country_set[country]._conditional_imr_ratio = mrs.loc[country, &#39;imrs&#39;]  # 1 / P^{1-sigma}
                    self.country_set[country]._conditional_omr_ratio = mrs.loc[country, &#39;omrs&#39;]  # 1 / π^{1-sigma}

    def _calculate_GEPPML_multilateral_resistance(self, version):
        &#39;&#39;&#39;
        Construct fixed effects according to Yotov, Piermartini, Monteiro, and Larch (2016),
        &#34;An Advanced Guide to Trade Policy Analysis: The Structural Gravity Model (Online Revised Version)
        Follows GEPPML approach and MRLs are based on equations (2-38) and (2-39)
        &#39;&#39;&#39;
        country_list = list(self.country_set.keys())

        # ToDo: Try recalculating the output expenditure measures

        def _GEPPML_OMR(Y_i, E_R, exp_fe_i):
            &#39;&#39;&#39;
            Calculate outward multilateral resistance based on equation (2-38): π_i^(1-sigma)
                Y_i: Output for exporter i
                E_r: Expenditure for the reference country
                exp_fe_i: Estimated exporter fixed effect for country i
            &#39;&#39;&#39;
            return (Y_i * E_R) / math.exp(exp_fe_i)

        def _GEPPML_IMR(E_j, E_R, imp_fe_j):
            &#39;&#39;&#39;
            Calculate inward multilateral resistance based on equation (2-39): P_j^(1-sigma)
                E_j: Expenditure for importer j
                E_R: Expenditure for the reference country
                imp_fe_j: Estimated importer fixed effect for country j
            &#39;&#39;&#39;
            return E_j / (math.exp(imp_fe_j) * E_R)

        if version == &#39;baseline&#39;:
            reference_expnd = self.country_set[self._reference_importer].baseline_expenditure
            for country in country_list:
                country_obj = self.country_set[country]

                # Set values for reference importer
                if country == self._reference_importer:

                    # Check that the estimation produced appropriate fixed effect estimates
                    if country_obj.baseline_importer_fe != &#39;no estimate&#39;:
                        warn(&#34;There exists an importer fixed effect estimate for the reference country.&#34;
                             &#34; Check that the fixed effect specification correctly omits the reference country&#34;)
                    if country_obj.baseline_exporter_fe == &#39;no estimate&#39;:
                        raise ValueError(&#34;No exporter fixed effect estimate for {}&#34;.format(country))
                    # P_R = 1 by construction
                    imr = 1
                    # π_i^(1-sigma)
                    omr = _GEPPML_OMR(Y_i=country_obj.baseline_output, E_R=reference_expnd,
                                      exp_fe_i=country_obj.baseline_exporter_fe)
                    self.country_set[country]._baseline_imr_ratio = 1 / imr  # 1 / P^{1-sigma}
                    self.country_set[country]._baseline_omr_ratio = 1 / omr  # 1 / π^{1-sigma}

                # Set values for every other country
                else:
                    # Check that there exist fixed effect estimates
                    if country_obj.baseline_importer_fe == &#39;no estimate&#39;:
                        raise ValueError(&#34;No importer fixed effect estimate for {}&#34;.format(country))
                    if country_obj.baseline_exporter_fe == &#39;no estimate&#39;:
                        raise ValueError(&#34;No exporter fixed effect estimate for {}&#34;.format(country))
                    # π_i^(1-sigma)
                    omr = _GEPPML_OMR(Y_i=country_obj.baseline_output, E_R=reference_expnd,
                                      exp_fe_i=country_obj.baseline_exporter_fe)
                    # P_j^(1-sigma)
                    imr = _GEPPML_IMR(E_j=country_obj.baseline_expenditure, E_R=reference_expnd,
                                      imp_fe_j=country_obj.baseline_exporter_fe)

                    self.country_set[country]._baseline_imr_ratio = 1 / imr  # 1 / P^{1-sigma}
                    self.country_set[country]._baseline_omr_ratio = 1 / omr  # 1 / π^{1-sigma}

        if version == &#39;conditional&#39;:
            # Step 1: Re-estimate model
            baseline_specification = self._estimation_model.specification
            counter_factual_data = self.experiment_data.copy()
            counter_factual_data = counter_factual_data.merge(self.experiment_trade_costs, how=&#39;inner&#39;,
                                                              on=[self.meta_data.exp_var_name,
                                                                  self.meta_data.imp_var_name,
                                                                  self.meta_data.year_var_name])
            counter_factual_data[&#39;adjusted_trade&#39;] = counter_factual_data[baseline_specification.lhs_var] / \
                                                     counter_factual_data[&#39;trade_cost&#39;]
            # ToDo: Perform estimation - May not work with GME.estimate() due to lack of rhs vars. If so, need to figure out how to deal with dropped FE in estimation stage.

            # ToDo: Step 2: Calculate shit.


    def _calculate_baseline_factory_gate_params(self):
        for country in self.country_set.keys():
            self.country_set[country].factory_gate_price_param = self.country_set[country].baseline_output_share \
                                                                 * self.country_set[country]._baseline_omr_ratio

    def define_experiment(self, experiment_data: DataFrame):
        &#39;&#39;&#39;
        Specify the counterfactual data to use for experiment.
        Args:
            experiment_data(Pandas.DataFrame): A dataframe contianing the counterfactual trade-cost data to use for the
                experiment. The best approach for creating this data is to copy the baseline data
                (OneSectorGE.baseline_data.copy()) and modify columns/rows to reflect desired counterfactual experiment.

        Returns:
            None:
                There is no return but the new information is added to model.
        &#39;&#39;&#39;
        if not self._baseline_built:
            raise ValueError(&#34;Baseline must be built first (i.e. ge_model.build_baseline() method&#34;)
        self.experiment_data = experiment_data
        self.experiment_trade_costs = self._create_trade_costs(self.experiment_data)
        cost_change = self.baseline_trade_costs.merge(right=self.experiment_trade_costs, how=&#39;outer&#39;,
                                                      on=[self.meta_data.imp_var_name,
                                                          self.meta_data.exp_var_name,
                                                          self.meta_data.year_var_name])
        cost_change.rename(columns={&#39;trade_cost_x&#39;: &#39;baseline_trade_cost&#39;, &#39;trade_cost_y&#39;: &#39;experiment_trade_cost&#39;},
                           inplace=True)
        self.cost_shock = cost_change.loc[cost_change[&#39;baseline_trade_cost&#39;] != cost_change[&#39;experiment_trade_cost&#39;]]
        self._experiment_defined = True

    def simulate(self, ge_method: str = &#39;hybr&#39;, ge_tolerance: float = 1e-8, ge_max_iter: int = 1000):
        &#39;&#39;&#39;
        Simulate the counterfactual scenario
        Args:
            ge_method (str): (optional) The solver method to use for the full GE non-linear solver. See scipy.root()
                documentation for option. Default is &#39;hybr&#39;.
            ge_tolerance (float): (optional) The tolerance for determining if the GE system of equations is solved.
                Default is 1e-8.
            ge_max_iter (int): (optional) The maximum number of iterations allowed for the full GE nonlinear solver.
                Default is 1000.

        Returns:
            None
                No return but populates new attributes of model.
        &#39;&#39;&#39;
        # &#39;&#39;&#39;
        # Simulate the counterfactual scenario.
        # :param ge_method: (str)
        # :param ge_tolerance: (float)
        #
        # :param ge_max_iter: (int)
        # :return: (None) No return but many fields in the model containing results are populated.
        # &#39;&#39;&#39;
        if not self._baseline_built:
            raise ValueError(&#34;Baseline must be built first (i.e. OneSectorGE.build_baseline() method&#34;)
        if not self._experiment_defined:
            raise ValueError(&#34;Expiriment must be defined first (i.e. OneSectorGE.define_expiriment() method&#34;)
        self._ge_method = ge_method
        self._ge_tolerance = ge_tolerance
        self._ge_max_iter = ge_max_iter
        # Step 1: Simulate conditional GE
        if self.approach == &#39;GEPPML&#39;:
            self._calculate_GEPPML_multilateral_resistance(version=&#39;conditional&#39;)
        else:
            self._calculate_multilateral_resistance(trade_costs=self.experiment_trade_costs, version=&#39;conditional&#39;)
        # Step 2: Simulate full GE
        self._calculate_full_ge()
        # Step 3: Generate post-simulation results
        [self.country_set[country]._construct_country_measures(sigma=self.sigma) for country in self.country_set.keys()]
        self._construct_experiment_output_expend()
        self._construct_experiment_trade()
        self._compile_results()

    def _calculate_full_ge(self):
        # Solve Full GE model
        ge_params = dict()
        country_list = list(self.country_set.keys())
        country_list.sort()
        ge_params[&#39;number_of_countries&#39;] = len(country_list)
        ge_params[&#39;omr_rescale&#39;] = self._omr_rescale
        ge_params[&#39;imr_rescale&#39;] = self._imr_rescale
        ge_params[&#39;sigma&#39;] = self.sigma
        # Calculate parameters reflecting trade costs, output shares, and expenditure shares
        cost_shr_params = self._create_cost_output_expend_params(trade_costs=self.experiment_trade_costs)
        ge_params[&#39;cost_exp_shr&#39;] = cost_shr_params[&#39;cost_exp_shr&#39;]
        ge_params[&#39;cost_out_shr&#39;] = cost_shr_params[&#39;cost_out_shr&#39;]

        init_imr = list()
        init_omr = list()
        output_share = list()
        factory_gate_params = list()
        for country in country_list:
            init_imr.append(self.country_set[country]._conditional_imr_ratio)
            init_omr.append(self.country_set[country]._conditional_omr_ratio)
            output_share.append(self.country_set[country].baseline_output_share)
            factory_gate_params.append(self.country_set[country].factory_gate_price_param)

        init_imr = [mr / ge_params[&#39;imr_rescale&#39;] for mr in init_imr]
        init_omr = [mr / ge_params[&#39;omr_rescale&#39;] for mr in init_omr]

        ge_params[&#39;output_shr&#39;] = output_share
        ge_params[&#39;factory_gate_param&#39;] = factory_gate_params

        init_price = [1] * len(country_list)
        initial_values = init_imr[0:len(country_list) - 1] + init_omr + init_price
        initial_values = np.array(initial_values)
        if not self.quiet:
            print(&#39;Solving full GE model...&#39;)
        full_ge_results = root(_full_ge, initial_values, args=ge_params, method=self._ge_method, tol=self._ge_tolerance,
                               options={&#39;xtol&#39;: self._ge_tolerance, &#39;maxfev&#39;: self._ge_max_iter})
        if full_ge_results.message == &#39;The solution converged.&#39;:
            if not self.quiet:
                print(full_ge_results.message)
        else:
            warn(full_ge_results.message)
        self.solver_diagnostics[&#39;full_GE&#39;] = full_ge_results

        imrs = full_ge_results.x[0:len(country_list) - 1] * ge_params[&#39;imr_rescale&#39;]
        imrs = np.append(imrs, 1)
        omrs = full_ge_results.x[len(country_list) - 1:2 * len(country_list) - 1] * ge_params[&#39;omr_rescale&#39;]
        prices = full_ge_results.x[2 * len(country_list) - 1:]
        factory_gate_prices = pd.DataFrame({&#39;exporter&#39;: country_list,
                                            self.labels.experiment_factory_price: prices})
        self.factory_gate_prices = factory_gate_prices.set_index(&#39;exporter&#39;)
        for i, country in enumerate(country_list):
            self.country_set[country]._experiment_imr_ratio = imrs[i] # 1 / P^{1-sigma}
            self.country_set[country]._experiment_omr_ratio = omrs[i] # 1 / π^{1-sigma}
            self.country_set[country].experiment_factory_price = prices[i]
            self.country_set[country].factory_price_change = 100 * (prices[i] - 1)


    def _construct_experiment_output_expend(self):
        total_output = 0

        results_table = pd.DataFrame(columns=[self.labels.identifier,
                                              self.labels.baseline_output,
                                              self.labels.experiment_output,
                                              self.labels.output_change,
                                              self.labels.baseline_expenditure,
                                              self.labels.experiment_expenditure,
                                              self.labels.expenditure_change])
        # The first time looping through gets calculates total output
        for country in self.country_set.keys():
            country_obj = self.country_set[country]
            total_output += country_obj.experiment_output

        # The second time looping through gets things that are dependent on total output/expenditure
        for country in self.country_set.keys():
            country_obj = self.country_set[country]
            country_obj.experiment_output_share = country_obj.experiment_output / total_output
            results_table = results_table.append({
                self.labels.identifier: country,
                self.labels.baseline_output: country_obj.baseline_output,
                self.labels.experiment_output: country_obj.experiment_output,
                self.labels.output_change: country_obj.output_change,
                self.labels.baseline_expenditure: country_obj.baseline_expenditure,
                self.labels.experiment_expenditure: country_obj.experiment_expenditure,
                self.labels.expenditure_change: country_obj.expenditure_change},
                                                 ignore_index=True)
        # Store some economy-wide values to economy object
        self.economy.experiment_total_output = total_output
        self.economy.output_change = 100 * (total_output - self.economy.baseline_total_output) \
                                     / self.economy.baseline_total_output

        results_table = results_table.set_index(self.labels.identifier)
        # Ensure all values are numeric
        for col in results_table.columns:
            results_table[col] = results_table[col].astype(float)
        # Save to model
        self.outputs_expenditures = results_table

    def _construct_experiment_trade(self):
        &#39;&#39;&#39;
        Construct simulated bilateral trade values.
        :return: None. It sets the values for self.bilateral_trade_results, self.aggregate_trade_results, and many of
        the trade attributes in the country objects.
        &#39;&#39;&#39;
        importer_col = self.meta_data.imp_var_name
        exporter_col = self.meta_data.exp_var_name
        year_col = self.meta_data.year_var_name
        trade_value_col = self.meta_data.trade_var_name

        countries = self.country_set.keys()
        trade_data = self.baseline_data[[exporter_col, importer_col, year_col, trade_value_col]].copy()
        trade_data = trade_data.loc[trade_data[year_col] == self._year, [exporter_col, importer_col, trade_value_col]]

        trade_data.rename(columns={trade_value_col: &#39;baseline_trade&#39;}, inplace=True)

        # Set Placeholder value
        #trade_data[&#39;gravity&#39;] = -9999

        # Construct Modeled trade for each country-pair
        for row in trade_data.index:
            # Collect importer and exporter IDs
            importer = trade_data.loc[row, importer_col]
            exporter = trade_data.loc[row, exporter_col]

            # Collect and generate Experiment Values
            exp_imr_ratio = self.country_set[importer]._experiment_imr_ratio
            exp_omr_ratio = self.country_set[exporter]._experiment_omr_ratio
            expend = self.country_set[importer].experiment_expenditure
            output_share = self.country_set[exporter].experiment_output_share
            # gravity = E_j  *   Y_i/Y      * 1/P_j^{1-sigma} * 1/π_i^{1-sigma}
            gravity = expend * output_share * exp_imr_ratio * exp_omr_ratio
            trade_data.loc[row, &#39;exper_gravity&#39;] = gravity

            # Collect and generate baseline values
            bsln_imr_ratio = self.country_set[importer]._baseline_imr_ratio
            bsln_omr_ratio = self.country_set[exporter]._baseline_omr_ratio
            bsln_expend = self.country_set[importer].baseline_expenditure
            bsln_output_share = self.country_set[exporter].baseline_output_share
            # &#39;gravity&#39; term = E_j     *   Y_i/Y           * 1/P_j^{1-sigma} * 1/π_i^{1-sigma}
            bsln_gravity = bsln_expend * bsln_output_share * bsln_imr_ratio * bsln_omr_ratio
            trade_data.loc[row, &#39;bsln_gravity&#39;] = bsln_gravity

        trade_data = trade_data.merge(self.baseline_trade_costs, how=&#39;left&#39;, on=[importer_col, exporter_col])
        trade_data.rename(columns={&#39;trade_cost&#39;: &#39;baseline_trade_cost&#39;}, inplace=True)

        # Set column labels from label dictionary
        bsln_modeled_trade_label = self.labels.baseline_modeled_trade
        exper_trade_label = self.labels.experiment_trade
        trade_change_label = self.labels.trade_change

        trade_data[bsln_modeled_trade_label] = trade_data[&#39;baseline_trade_cost&#39;] \
                                                                   * trade_data[&#39;bsln_gravity&#39;]

        trade_data = trade_data.merge(self.experiment_trade_costs, how=&#39;left&#39;, on=[importer_col, exporter_col])

        trade_data[exper_trade_label] = trade_data[&#39;trade_cost&#39;] * trade_data[&#39;exper_gravity&#39;]

        trade_data[trade_change_label] = 100 * (trade_data[exper_trade_label] - trade_data[bsln_modeled_trade_label]) \
                                       / trade_data[bsln_modeled_trade_label]

        bilateral_trade_results = trade_data[[exporter_col, importer_col, bsln_modeled_trade_label,
                                                   exper_trade_label, trade_change_label]]
        self.bilateral_trade_results = bilateral_trade_results.set_index([exporter_col, importer_col])

        ##
        # Calculate total Imports (international and domestic)
        ##
        # set more labels from label dictionary
        bsln_agg_imports_label = self.labels.baseline_imports
        exper_agg_imports_label = self.labels.experiment_imports
        agg_import_change_label = self.labels.imports_change

        agg_imports = bilateral_trade_results.copy()
        agg_imports = agg_imports[[importer_col, bsln_modeled_trade_label, exper_trade_label]]
        agg_imports = agg_imports.groupby([importer_col]).agg(&#39;sum&#39;)
        agg_imports.rename(columns={bsln_modeled_trade_label: bsln_agg_imports_label,
                                    exper_trade_label: exper_agg_imports_label}, inplace=True)
        agg_imports[agg_import_change_label] = 100 \
                                               * (agg_imports[exper_agg_imports_label] - agg_imports[bsln_agg_imports_label]) \
                                               / agg_imports[bsln_agg_imports_label]
        ##
        # Calculate foreign imports
        ##
        # set more labels from label dictionary
        bsln_agg_frgn_imports_label = self.labels. baseline_foreign_imports
        exper_agg_frgn_imports_label = self.labels.experiment_foreign_imports
        agg_frgn_import_change_label = self.labels.foreign_imports_change

        foreign_imports = bilateral_trade_results.copy()
        foreign_imports = foreign_imports.loc[foreign_imports[importer_col]!=foreign_imports[exporter_col],:]
        foreign_imports = foreign_imports[[importer_col, bsln_modeled_trade_label, exper_trade_label]]
        foreign_imports = foreign_imports.groupby([importer_col]).agg(&#39;sum&#39;)
        foreign_imports.rename(columns={bsln_modeled_trade_label: bsln_agg_frgn_imports_label,
                                    exper_trade_label: exper_agg_frgn_imports_label}, inplace=True)
        foreign_imports[agg_frgn_import_change_label] = 100 \
                                               * (foreign_imports[exper_agg_frgn_imports_label] - foreign_imports[bsln_agg_frgn_imports_label]) \
                                               / foreign_imports[bsln_agg_frgn_imports_label]

        ##
        # Calculate total exports (foreign + domestic)
        ##
        # Set labels from label dictionary
        bsln_agg_exports_label = self.labels.baseline_exports
        exper_agg_exports_label = self.labels. experiment_exports
        agg_exports_change_label = self.labels.exports_change

        agg_exports = bilateral_trade_results.copy()
        agg_exports = agg_exports[[exporter_col, bsln_modeled_trade_label, exper_trade_label]]
        agg_exports = agg_exports.groupby([exporter_col]).agg(&#39;sum&#39;)
        agg_exports.rename(columns={bsln_modeled_trade_label: bsln_agg_exports_label,
                                    exper_trade_label: exper_agg_exports_label}, inplace=True)
        agg_exports[agg_exports_change_label] = 100 \
                                               * (agg_exports[exper_agg_exports_label] - agg_exports[bsln_agg_exports_label]) \
                                               / agg_exports[bsln_agg_exports_label]
        ##
        # Calculate foreign exports
        ##
        # Set labels from label dictionary
        bsln_agg_frgn_exports_label = self.labels.baseline_foreign_exports
        exper_agg_frgn_exports_label = self.labels.experiment_foreign_exports
        agg_frgn_exports_change_label = self.labels.foreign_exports_change

        foreign_exports = bilateral_trade_results.copy()
        foreign_exports = foreign_exports.loc[foreign_exports[importer_col] != foreign_exports[exporter_col], :]
        foreign_exports = foreign_exports[[exporter_col, bsln_modeled_trade_label, exper_trade_label]]
        foreign_exports = foreign_exports.groupby([exporter_col]).agg(&#39;sum&#39;)
        foreign_exports.rename(columns={bsln_modeled_trade_label: bsln_agg_frgn_exports_label,
                                        exper_trade_label: exper_agg_frgn_exports_label}, inplace=True)
        foreign_exports[agg_frgn_exports_change_label] = 100 \
                                                           * (foreign_exports[exper_agg_frgn_exports_label] -
                                                              foreign_exports[bsln_agg_frgn_exports_label]) \
                                                           / foreign_exports[bsln_agg_frgn_exports_label]


        agg_trade = pd.concat([agg_exports, foreign_exports, agg_imports, foreign_imports], axis=1).reset_index()
        agg_trade.rename(columns={&#39;index&#39;: self.labels.identifier}, inplace=True)


        # ----
        # Get Intranational Trade
        # ----
        bsln_intra_label = self.labels.baseline_intranational_trade
        exper_intra_label = self.labels.experiment_intranational_trade
        intra_change_label = self.labels.intranational_trade_change
        intranational = bilateral_trade_results.copy()
        intranational = intranational.loc[intranational[importer_col] == intranational[exporter_col], :]
        intranational.drop([importer_col], axis = 1, inplace = True)
        intranational.rename(columns= {exporter_col:self.labels.identifier,
                                       bsln_modeled_trade_label:bsln_intra_label,
                                       exper_trade_label:exper_intra_label,
                                       trade_change_label:intra_change_label}, inplace = True)

        agg_trade = agg_trade.merge(intranational, on = self.labels.identifier)

        # Store values in each country object
        for row in agg_trade.index:
            country = agg_trade.loc[row, self.labels.identifier]
            country_obj = self.country_set[country]
            country_obj.baseline_imports = agg_trade.loc[row, bsln_agg_imports_label]
            country_obj.baseline_exports = agg_trade.loc[row, bsln_agg_exports_label]
            country_obj.baseline_foreign_imports = agg_trade.loc[row, bsln_agg_frgn_imports_label]
            country_obj.baseline_foreign_exports = agg_trade.loc[row, bsln_agg_frgn_exports_label]
            country_obj.experiment_imports = agg_trade.loc[row, exper_agg_imports_label]
            country_obj.experiment_exports = agg_trade.loc[row, exper_agg_exports_label]
            country_obj.imports_change = agg_trade.loc[row, agg_import_change_label]
            country_obj.exports_change = agg_trade.loc[row, agg_exports_change_label]
            country_obj.experiment_foreign_imports = agg_trade.loc[row, exper_agg_frgn_imports_label]
            country_obj.experiment_foreign_exports = agg_trade.loc[row, exper_agg_frgn_exports_label]
            country_obj.foreign_imports_change = agg_trade.loc[row, agg_frgn_import_change_label]
            country_obj.foreign_exports_change = agg_trade.loc[row, agg_frgn_exports_change_label]
            country_obj.baseline_intranational_trade = agg_trade.loc[row, bsln_intra_label]
            country_obj.experiment_intranational_trade = agg_trade.loc[row, exper_intra_label]
            country_obj.intranational_trade_change = agg_trade.loc[row, intra_change_label]

        self.aggregate_trade_results = agg_trade.set_index(self.labels.identifier)

    def _compile_results(self):
        &#39;&#39;&#39;Generate and compile results after simulations&#39;&#39;&#39;
        results = list()
        mr_results = list()
        for country in self.country_set.keys():
            results.append(self.country_set[country].get_results(self.labels))
            mr_results.append(self.country_set[country].get_mr_results(self.labels))
        country_results = pd.concat(results, axis=0)
        self.country_results = country_results.set_index(self.labels.identifier)
        country_mr_results = pd.concat(mr_results, axis=0)
        self.country_mr_terms = country_mr_results.set_index(self.labels.identifier)


    def trade_share(self, importers: List[str], exporters: List[str]):
        &#39;&#39;&#39;
        Calculate baseline and experiment import and export shares (in percentages) between user-supplied countries.
        Args:
            importers (list[str]): A list of country codes to include as import partners.
            exporters (list[str]): A list of country codes to include as export partners.

        Returns:
            pandas.DataFrame: A dataframe expressing baseline, experiment, and changes in trade between each specified importer and exporter.
        &#39;&#39;&#39;
        # &#39;&#39;&#39;
        #
        # :param importers:  A list of country codes to include as import partners.
        # :param exporters: (list[str]) A list of country codes to include as export partners.
        # :return: (DataFrame)
        # &#39;&#39;&#39;
        importer_col = self.meta_data.imp_var_name
        exporter_col = self.meta_data.exp_var_name
        bsln_modeled_trade_label = self.labels.baseline_modeled_trade
        exper_trade_label = self.labels.experiment_trade

        bilat_trade = self.bilateral_trade_results.reset_index()
        columns = [bsln_modeled_trade_label, exper_trade_label]
        imports = bilat_trade.loc[bilat_trade[importer_col].isin(importers), :].copy()
        exports = bilat_trade.loc[bilat_trade[&#39;exporter&#39;].isin(exporters), :].copy()

        total_imports = imports[columns].agg(&#39;sum&#39;)
        total_exports = exports[columns].agg(&#39;sum&#39;)

        selected_imports = imports.loc[imports[&#39;exporter&#39;].isin(exporters), columns].copy().agg(&#39;sum&#39;)
        selected_exports = exports.loc[exports[importer_col].isin(importers), columns].copy().agg(&#39;sum&#39;)

        import_data = 100 * selected_imports / total_imports
        export_data = 100 * selected_exports / total_exports

        import_data[&#39;description&#39;] = &#39;Percent of &#39; + &#34;, &#34;.join(importers) + &#39; imports from &#39; + &#34;, &#34;.join(exporters)
        export_data[&#39;description&#39;] = &#39;Percent of &#39; + &#34;, &#34;.join(exporters) + &#39; exports to &#39; + &#34;, &#34;.join(importers)

        both = pd.concat([import_data, export_data], axis=1).T
        both = both[[&#39;description&#39;] + columns]
        both[&#39;change (percentage point)&#39;] = (both[exper_trade_label] - both[bsln_modeled_trade_label])
        both[&#39;change (%)&#39;] = 100 * (both[exper_trade_label] - both[bsln_modeled_trade_label]) / \
                                   both[bsln_modeled_trade_label]

        return both

    def export_results(self, directory:str = None, name:str = &#39;&#39;,
                       include_levels:bool = False, country_names:DataFrame = None):
        &#39;&#39;&#39;
        Export results to csv files. Three files are stored containing (1) country-level results, (2) bilateral results,
        and (3) solver diagnostics.
        Args:
            directory (str): (optional) Directory in which to write results files. If no directory is supplied,
                three compiled dataframes are returned as a tuple in the order (Country-level results, bilateral
                results, solver diagnostics).
            name (str): (optional) Name of the simulation to prefix to the result file names.
            include_levels (bool): (optional) If True, includes additional columns reflecting the simulated changes in
                levels based on observed trade flows (rather than modeled trade flows). Values are those from the
                method calculate_levels.
            country_names (pandas.DataFrame): (optional) Adds alternative identifiers such as names to the returned
                results tables. The supplied DataFrame should include exactly two columns. The first column must be
                the country identifiers used in the model. The second column must be the alternative identifiers to
                add.

        Returns:
            None or Tuple[DataFrame, DataFrame, DataFrame]: If a directory argument is supplied, the method returns
                nothing and writes three .csv files instead. If no directory is supplied, it returns a tuple of DataFrames.
        &#39;&#39;&#39;

        importer_col = self.meta_data.imp_var_name
        exporter_col = self.meta_data.exp_var_name

        country_result_set = [self.country_results, self.factory_gate_prices, self.aggregate_trade_results,
                              self.outputs_expenditures, self.country_mr_terms]
        country_results = pd.concat(country_result_set, axis = 1)
        # Order and select columns for inclusion, drop duplicates.
        country_results_cols = country_results.columns
        labs = self.labels
        # Country results to include
        results_cols = self.labels.country_level_labels

        included_columns = [col for col in results_cols if col in country_results_cols]
        country_results = country_results[included_columns]
        country_results = country_results.loc[:, ~country_results.columns.duplicated()]

        bilateral_results = self.bilateral_trade_results.reset_index()

        if include_levels:
            country_levels = self.calculate_levels(how = &#39;country&#39;)
            duplicate_columns = [col for col in country_levels.columns if col in country_results.columns]
            country_levels.drop(duplicate_columns,axis = 1, inplace = True)
            country_results = country_results.merge(country_levels, how = &#39;left&#39;, left_index = True, right_index = True)

            bilateral_levels = self.calculate_levels(how=&#39;bilateral&#39;)
            duplicate_columns = [col for col in bilateral_levels.columns if (col in bilateral_results.columns)
                                 and col not in [exporter_col, importer_col]]
            bilateral_levels.drop(duplicate_columns, axis=1, inplace=True)
            bilateral_results = bilateral_results.merge(bilateral_levels, how=&#39;left&#39;, on = [exporter_col, importer_col])

        if country_names is not None:
            if country_names.shape[1]!=2:
                raise ValueError(&#34;country_names should have exactly 2 columns, not {}&#34;.format(country_names.shape[1]))
            code_col = country_names.columns[0]
            name_col = country_names.columns[1]
            country_names.set_index(code_col, inplace = True, drop = True)
            country_results = country_names.merge(country_results, how = &#39;right&#39;, left_index = True, right_index=True)

            # Add names to bilateral data
            for side in [exporter_col, importer_col]:
                side_names = country_names.copy()
                side_names.reset_index(inplace = True)
                side_names.rename(columns = {code_col:side, name_col:&#34;{} {}&#34;.format(side,name_col)}, inplace = True)
                bilateral_results = bilateral_results.merge(side_names, how = &#39;left&#39;, on = side)





        # Create Dataframe with Diagnostic results
        diagnostics = self.solver_diagnostics
        column_list = list()
        # Iterate through the three solver types: baseline_MRs, conditional_MRs, and Full_GE
        for results_type, results in diagnostics.items():
            for key, value in results.items():
                # Single Entry fields must be converted to list before creating DataFrame
                if key in [&#39;success&#39;, &#39;status&#39;, &#39;nfev&#39;, &#39;message&#39;]:
                    frame = pd.DataFrame({(results_type, key): [value]})
                    column_list.append(frame)
                # Vector-like fields Can be used as is. Several available fields are not included: &#39;fjac&#39;,&#39;r&#39;, and &#39;qtf&#39;
                elif key in [&#39;x&#39;, &#39;fun&#39;]:
                    frame = pd.DataFrame({(results_type, key): value})
                    column_list.append(frame)
        diag_frame = pd.concat(column_list, axis=1)
        diag_frame = diag_frame.fillna(&#39;&#39;)


        if directory is not None:
            country_results.to_csv(&#34;{}/{}_country_results.csv&#34;.format(directory, name))
            bilateral_results.to_csv(&#34;{}/{}_bilateral_results.csv&#34;.format(directory, name), index = False)
            diag_frame.to_csv(&#34;{}/{}_solver_diagnostics.csv&#34;.format(directory, name), index = False)
        else:
            return country_results, bilateral_results, diagnostics

    def calculate_levels(self, how: str = &#39;country&#39;):
        &#39;&#39;&#39;
        Calculate changes in the level (value) of trade using baseline trade values and simulation outcomes. Results
            can be calculated at either the country level or bilateral level.
        Args:
            how (str):  If &#39;country&#39;, returned values are calculated at the country level (total exports, imports,
                and intranational). If &#39;bilateral&#39;, returned results are at the bilateral level. Default is &#39;country&#39;.

        Returns:
            pandas.DataFrame: A DataFrame containing baseline and experiment trade levels as well as the change expressed
                in levels and percentages. If calculated at the country level, these four measures are each returned for
                total imports, exports, and intranational trade. If calculated at the bilateral level, only one set of the
                measures is returned.
        &#39;&#39;&#39;
        if not self._baseline_built and self._experiment_defined:
            raise ValueError(&#39;Model must be fully solved before calculating levels.&#39;)
        exporter = self.meta_data.exp_var_name
        importer = self.meta_data.imp_var_name
        trade = self.meta_data.trade_var_name
        trade_flows = self.baseline_data.copy()
        trade_flows = trade_flows[[exporter, importer, trade]]
        bilateral_results = self.bilateral_trade_results[[self.labels.trade_change]].copy()
        bilateral_results.reset_index(inplace=True)
        #crl = country_results_labels

        # Coumpute at the country level (importer, exporter, and intranational)
        if how == &#39;country&#39;:
            intra_national = trade_flows.loc[trade_flows[exporter] == trade_flows[importer], [exporter, trade]]
            intra_national.set_index(exporter, inplace=True)
            international = trade_flows.loc[trade_flows[exporter] != trade_flows[importer], :]
            # Aggregate trade values
            foreign_exports = international.groupby(exporter).agg({trade: &#39;sum&#39;})
            foreign_imports = international.groupby(importer).agg({trade: &#39;sum&#39;})
            # Combine
            country_trade = foreign_exports.merge(foreign_imports, how=&#39;outer&#39;, left_index=True, right_index=True)
            country_trade = country_trade.merge(intra_national, how=&#39;outer&#39;, left_index=True, right_index=True)
            country_trade.columns = [self.labels.baseline_observed_foreign_exports,
                                     self.labels.baseline_observed_foreign_imports,
                                     self.labels.baseline_observed_intranational_trade]

            # Prep and add experiment change info
            experiment_results = self.country_results[[self.labels.foreign_exports_change,
                                                       self.labels.foreign_imports_change]].reset_index()
            intra_results = bilateral_results.loc[bilateral_results[exporter] == bilateral_results[importer],
                                                  [exporter, self.labels.trade_change]].copy()
            intra_results.rename(columns={exporter: &#39;country&#39;,
                                          self.labels.trade_change: self.labels.intranational_trade_change},
                                          inplace=True)
            experiment_results = pd.merge(experiment_results, intra_results, on=self.labels.identifier)
            experiment_results.set_index(self.labels.identifier, inplace=True)
            country_trade = country_trade.merge(experiment_results, how=&#39;outer&#39;, left_index=True, right_index=True)
            # Compute new levels
            for level, change in [(self.labels.baseline_observed_foreign_exports, self.labels.foreign_exports_change),
                                  (self.labels.baseline_observed_foreign_imports, self.labels.foreign_imports_change),
                                  (self.labels.baseline_observed_intranational_trade, self.labels.intranational_trade_change)]:

                new_level_name = level.replace(&#39;baseline&#39;, &#39;experiment&#39;)
                level_change_name = change.replace(&#39;%&#39;,&#39;observed level&#39;)
                country_trade[new_level_name] = country_trade[level] * (1 + (experiment_results[change] / 100))
                country_trade[level_change_name] = country_trade[new_level_name] - country_trade[level]

            result_order = list()
            for result_type in [&#39;exports&#39;,&#39;imports&#39;,&#39;intranational&#39;]:
                for sub_type in [&#39;baseline&#39;,&#39;experiment&#39;,&#39;level&#39;,&#39;%&#39;]:
                    for col in country_trade.columns:
                        if (sub_type in col) and (result_type in col):
                            result_order.append(col)

            return country_trade[result_order]
        # Compute at the bilateral level
        if how == &#39;bilateral&#39;:
            # Prep and add experiment change info
            experiment_results = bilateral_results
            bilat_trade = trade_flows.merge(experiment_results, on=[exporter, importer], how=&#39;outer&#39;)
            bilat_trade.rename(columns={trade: self.labels.baseline_observed_trade},
                               inplace=True)
            # Create changes in levels

            bilat_trade[self.labels.experiment_observed_trade] = bilat_trade[self.labels.baseline_observed_trade] * (
                        1 + (bilat_trade[self.labels.trade_change] / 100))
            bilat_trade[self.labels.trade_change_level] = bilat_trade[self.labels.experiment_observed_trade] - bilat_trade[self.labels.baseline_observed_trade]
            bilat_trade = bilat_trade[[exporter, importer, self.labels.baseline_observed_trade,
                                       self.labels.experiment_observed_trade, self.labels.trade_change_level, self.labels.trade_change]]
            return bilat_trade

    def trade_weighted_shock(self, how:str = &#39;country&#39;, aggregations:list=[&#39;mean&#39;, &#39;sum&#39;, &#39;max&#39;]):
        &#39;&#39;&#39;
        Create measures of trade weighted policy shocks to better understand which countries are most affected. Results
        reflect the absolute value of the change in trade costs multiplied by the
        Args:
            how (str): Determines the level of the results. If &#39;country&#39;, weighted shocks are returned at the country
                level for both importer and exporter using specified methods of aggregation. If &#39;bilateral&#39;, it returns the
                weighted shocks for all bilateral pairs. Default is &#39;country&#39;.
            aggregations (list[str]):  A list of methods by which to aggregate weighted shocks if how = &#39;country&#39;.
                List entries must be selected from those that are functional with the pandas.DataFrame.agg() method. The
                default value is [&#39;mean&#39;, &#39;sum&#39;, &#39;max&#39;].
        Returns:
            pandas.DataFrame: A dataframe of trade-weighted trade cost shocks.
        &#39;&#39;&#39;
        # Collect needed results
        bilat_trade = self.bilateral_trade_results.copy()
        bilat_trade.reset_index(inplace=True)
        cost_shock = self.cost_shock.copy()

        # Define column names
        imp_col = self.meta_data.imp_var_name
        exp_col = self.meta_data.exp_var_name
        baseline_trade_col = self.labels.baseline_modeled_trade
        baseline_cost_col = &#39;baseline_trade_cost&#39;
        exper_cost_col = &#39;experiment_trade_cost&#39;
        cost_change = &#39;cost_change&#39;
        weighted_col = &#39;weighted_shock&#39;

        # Create change in costs and add to bilateral trade
        cost_shock[cost_change] = abs(cost_shock[exper_cost_col] - cost_shock[baseline_cost_col])
        trade_shock = bilat_trade.merge(cost_shock, how=&#39;left&#39;, on=[imp_col, exp_col])
        trade_shock = trade_shock[[exp_col, imp_col, baseline_trade_col, cost_change]]
        # Fill cases with no change in costs with zero
        trade_shock.fillna(0, inplace=True)
        # Calculate weighted costs and normalize my largest weighted shock
        trade_shock[weighted_col] = trade_shock[baseline_trade_col] * trade_shock[cost_change]
        max_shock = max(trade_shock[weighted_col])
        trade_shock[weighted_col] = trade_shock[weighted_col] / max_shock

        # Create aggregate measures at importer and exporter level
        exporter_shocks = trade_shock.groupby(exp_col).agg({weighted_col: aggregations})
        exporter_shocks.columns = pd.MultiIndex.from_product(exporter_shocks.columns.levels + [[exp_col]])
        importer_shocks = trade_shock.groupby(imp_col).agg({weighted_col: aggregations})
        importer_shocks.columns = pd.MultiIndex.from_product(importer_shocks.columns.levels + [[imp_col]])
        weighted_shocks = pd.concat([exporter_shocks, importer_shocks], axis=1)

        if how == &#39;country&#39;:
            return weighted_shocks
        if how == &#39;bilateral&#39;:
            return trade_shock


    # ---
    # Diagnostic Tools
    # ---
    def test_baseline_mr_function(self, inputs_only:bool=False):
        &#39;&#39;&#39;
        Test whether the multilateral resistance system of equations can be computed from baseline data. Helpful for
            debugging initial data problems. Note that the returned function values reflect those generated by the
            initial values and do not reflect a solution to the system.
        Args:
            inputs_only (bool): If False (default), the method tests the computability of the MR system of equations
                and returns both the inputs to the system and the output. If True, only the system inputs are return and
                the equations are not computed and can help diagnose input issues that raise errors.
        Returns:
            dict: A dictionary containing a collection of parameter and value inputs as well as the function
                values at the initial values.
        &#39;&#39;&#39;
        test_diagnostics = self._calculate_multilateral_resistance(trade_costs=self.baseline_trade_costs,
                                                                   version=&#39;baseline&#39;, test=True,
                                                                   inputs_only=inputs_only)
        return test_diagnostics

    def check_omr_rescale(self,
                         omr_rescale_range:int = 10,
                         mr_method: str = &#39;hybr&#39;,
                         mr_max_iter: int = 1400,
                         mr_tolerance: float = 1e-8,
                         countries:List[str] = []):
        &#39;&#39;&#39;
        Analyze different Outward Multilarteral Resistance (OMR) term rescale factors. This method can help identify
            feasible values to use for the omr_rescale argument in OneSectorGE.build_baseline().
        Args:
            omr_rescale_range (int): This parameter allows you to set the scope of the values tested. For example,
                if omr_rescale_range = 3, the model will check for convergence using omr_rescale values from the set
                [10^-3, 10^-2, 10^-1, 10^0, ..., 10^3]. The default value is 10.
            mr_method (str): This parameter determines the type of non-linear solver used for solving the baseline and
                experiment MR terms. See the documentation for scipy.optimize.root for alternative methods. the default
                value is &#39;hybr&#39;.
            mr_max_iter (int): (optional) This parameter sets the maximum limit on the number of iterations conducted
                by the solver used to solve for MR terms. The default value is 1400.
            mr_tolerance (float): (optional) This parameterset the convergence tolerance level for the solver used to
                solve for MR terms. The default value is 1e-8.
            countries (List[str]):  A list of countries for which to return the estimated OMR values for user
                evaluation.
        Returns:
            pandas.DataFrame: A dataframe of diagnostic information for users to compare different omr_rescale factors.
                The returned dataframe contains the following columns:\n
                &#39;omr_rescale&#39;: The rescale factor used\n
                &#39;omr_rescale (alt format)&#39;: A string representation of the rescale factor as an exponential expression.\n
                &#39;solved&#39;: If True, the MR model solved successfully. If False, it did not solve.\n
                &#39;message&#39;: Description of the outcome of the solver.\n
                &#39;..._func_value&#39;: Three columns reflelcting the maximum, mean, and median values from the solver
                    objective functions. Function values closer to zero imply a better solution to system of equations.
                &#39;reference_importer_omr&#39;: The solution value for the reference importer&#39;s OMR value.\n
                &#39;..._omr&#39;: The solution value(s) for the user supplied countries.
        &#39;&#39;&#39;

        self._mr_max_iter = mr_max_iter
        self._mr_tolerance = mr_tolerance
        self._mr_method = mr_method
        self._imr_rescale = 1

        # Set up procedure for identifying usable omr_rescale
        findings = list()
        value_index = 0
        # Create list of rescale factors to test
        scale_values = range(-1*omr_rescale_range,omr_rescale_range+1)

        for scale_value in scale_values:
            value_results = dict()
            rescale_factor = 10 ** scale_value

            if not self.quiet:
                print(&#34;\nTrying OMR rescale factor of {}&#34;.format(rescale_factor))
            self._omr_rescale = rescale_factor
            self._calculate_multilateral_resistance(trade_costs=self.baseline_trade_costs,
                                                    version=&#39;baseline&#39;)
            value_results[&#39;omr_rescale&#39;] = rescale_factor
            value_results[&#39;omr_rescale (alt format)&#39;] = &#39;10^{}&#39;.format(scale_value)
            value_results[&#39;solved&#39;] = self.solver_diagnostics[&#39;baseline_MRs&#39;][&#39;success&#39;]
            value_results[&#39;message&#39;] = self.solver_diagnostics[&#39;baseline_MRs&#39;][&#39;message&#39;]
            func_vals = self.solver_diagnostics[&#39;baseline_MRs&#39;][&#39;fun&#39;]
            value_results[&#39;max_func_value&#39;] = func_vals.max()
            value_results[&#39;mean_func_value&#39;] = func_vals.mean()
            value_results[&#39;mean_func_value&#39;] = median(func_vals)
            value_results[&#39;reference_importer_omr&#39;] = self.country_set[self._reference_importer]._baseline_omr_ratio
            for country in countries:
                value_results[&#39;{}_omr&#39;.format(country)] = self.country_set[country]._baseline_omr_ratio
            findings.append(value_results)
        findings_table = pd.DataFrame(findings)

        return findings_table


def _multilateral_resistances(x, mr_params):
    &#39;&#39;&#39;
    System of equartions for the multilateral resistances
    :param x: (list) Values for the endogenous variables OMR π_i^(1-sigma) and IMR P_j^(1-sigma).
    :param mr_params: (dict) Additional exogeneous parameters
    :return: (list) the function value evaluated at x given mr_params
    &#39;&#39;&#39;
    # x should be length (n-1) + n (i.e. no IMR for the representative country)
    num_countries = mr_params[&#39;number_of_countries&#39;]
    cost_exp_shr = mr_params[&#39;cost_exp_shr&#39;]
    cost_out_shr = mr_params[&#39;cost_out_shr&#39;]
    imr_rescale = mr_params[&#39;imr_rescale&#39;]
    omr_rescale = mr_params[&#39;omr_rescale&#39;]

    # x_imr is IMR, N-1 elements
    x_imr = x[0:(num_countries - 1)]
    x_imr = [x * imr_rescale for x in x_imr]
    # x2 is OMR, N elements; multiplication by 1000 is done to correct the scaling problem
    x_omr = x[(num_countries - 1):]
    x_omr = [x * omr_rescale for x in x_omr]

    # Calculate IMR by looping over importers (j) excluding the reference country
    out = [1 - multiply(x_imr[j], sum(multiply(cost_out_shr[:, j], x_omr))) for j in range(num_countries - 1)]
    # Set last IMR for reference country equal to 1 for use in OMR calculation
    x_imr.append(1)
    # Calculate OMR by looping through exporters (i)
    out.extend([1 - multiply(x_omr[i], sum(multiply(cost_exp_shr[i, :], x_imr))) for i in range(num_countries)])
    return out


def _full_ge(x, ge_params):
    &#39;&#39;&#39;
    System of equations for the full-GE model
    :param x: (list) Values for the endogenous variables
    :param ge_params: (dict) Exogenous parameters for the equations including: number of countries, sigma, exogenous
        outpute, cost/expenditure, etc. shares, factory gate price parameter, and rescale factors.
    :return: (list) The value of the equations evaluated at x given ge_params.
    &#39;&#39;&#39;
    # Unpack Parameters
    num_countries = ge_params[&#39;number_of_countries&#39;]
    sigma_power = 1 - ge_params[&#39;sigma&#39;]
    out_share = ge_params[&#39;output_shr&#39;]
    cost_exp_shr = ge_params[&#39;cost_exp_shr&#39;]
    cost_out_shr = ge_params[&#39;cost_out_shr&#39;]
    beta = ge_params[&#39;factory_gate_param&#39;]
    omr_rescale = ge_params[&#39;omr_rescale&#39;]
    imr_rescale = ge_params[&#39;imr_rescale&#39;]

    # Break apart initial values vector
    # x_imr is IMR, N-1 elements
    x_imr = x[0:(num_countries - 1)] * imr_rescale
    # x2 is OMR, N elements; multiplication by 1000 is done to correct the scaling problem
    x_omr = x[(num_countries - 1):(2 * num_countries - 1)] * omr_rescale
    x_price = x[(2 * num_countries - 1):]

    # Calculate IMR by looping over importers (j) excluding the reference country
    out = [1 - multiply(x_imr[j], sum(multiply(cost_out_shr[:, j], x_omr))) for j in range(num_countries - 1)]
    # Set last IMR for reference country equal to 1 for use in OMR calculation
    x_imr = np.append(x_imr, 1)
    # Calculate OMR by looping through exporters (i)
    out.extend([1 - multiply(x_omr[i], sum(multiply(cost_exp_shr[i, :], x_imr))) for i in range(num_countries)])
    # Calculate factory gate prices by looping through countries (exporters)
    out.extend([1 - ((out_share[i] * x_omr[i]) / (beta[i] * x_price[i] ** sigma_power)) for i in range(num_countries)])
    return out


class Economy(object):
    &#39;&#39;&#39;
    Object for storing economy-wide information.
    &#39;&#39;&#39;
    def __init__(self,
                 sigma: float = 4):
        self.sigma = sigma
        self.experiment_total_output = None
        self.experiment_total_expenditure = None
        self.baseline_total_output = None
        self.baseline_total_expenditure = None
        self.output_change = None

    def _initialize_baseline_total_output_expend(self, country_set):
        # Create baseline values for total output and expenditure
        total_output = 0
        total_expenditure = 0
        for country in country_set.keys():
            total_output += country_set[country].baseline_output
            total_expenditure += country_set[country].baseline_expenditure
        self.baseline_total_output = total_output
        self.baseline_total_expenditure = total_expenditure

    def __repr__(self):
        return &#34;Economy \n&#34; \
               &#34;Sigma: {0} \n&#34; \
               &#34;Baseline Total Output: {1} \n&#34; \
               &#34;Baseline Total Expenditure: {2} \n&#34; \
               &#34;Experiment Total Output: {3} \n&#34; \
               &#34;Output Change (%): {4} \n&#34; \
            .format(self.sigma,
                    self.baseline_total_output,
                    self.baseline_total_expenditure,
                    self.experiment_total_output,
                    self.output_change)


class Country(object):
    &#39;&#39;&#39;
    An object for housing country-level information

    Attributes:
        identifier (str): Country name or identifier.
        year (str): The year used for analysis.
        baseline_output (float): User supplied baseline output ($Y_i$).
        baseline_output_share (float): Share of country output in total world outpur (Y_i/Y).
        experiment_output (float): Estimated counterfactual output (Y&#39;_i).
        output_change (float): Estimated percent change in output (100*[Y&#39; - Y]/Y).
        baseline_expenditure (float): User supplied baseline expenditure (E_j).
        baseline_expenditure_share (float): Share of country expenditure in total world expenditure (E_j/E).
        experiment_expenditure (float): Estimated counterfctual expenditure (E&#39;_j).
        expenditure_change (float): Estimated percent change in expenditure (100*[E&#39; - E]/E).
        baseline_importer_fe (float): Estimated importer or importer-year fixed effect, if supplied in estimation model.
        baseline_exporter_fe (float): Estimated exporter or exporter-year fixed effect, if supplied in estimation model.

        baseline_imr (float): Baseline inward multilateral resistance term (P_j).
        conditional_imr (float): Conditional (partial) equilibrium counterfactual experiment inward multilateral
            resistance term.
        experiment_imr (float): Estimated full GE, counterfactual inward multilateral resistance term (P&#39;\_j).
        imr_change (float): Estimated percent change in inward multilateral resistance term (100*[P&#39;-P]/P).

        baseline_omr (float): Baseline outward multilateral resistance term (π_i).
        conditional_omr (float): Conditional (partial) equilibrium counterfactual experiment outward multilateral
            resistance term.
        experiment_omr (float): Estimated full GE, counterfactual outward multilateral resistance term (π&#39;\_i).
        omr_change (float): Estimated percent change in inward multilateral resistance term (100*[π&#39;-π]/π).

        factory_gate_price_param (float): Calibrated factory gate price parameter (ß_i).
        baseline_factory_price (float): Baseline factory gate price (p_i), normalized to 1 by construction.
        experiment_factory_price (float): Estimated counterfactual factory gate price (p&#39;_i).
        factory_price_change (float): Estimated percent change in factory gate prices (100*[p*-p]/p).

        baseline_terms_of_trade (float): Baseline terms of trade (ToT_i = p_i/P_i).
        experiment_terms_of_trade (float): Estimated counterfactual terms of trade (ToT&#39;_i = p&#39;_i/P&#39;_i).
        terms_of_trade_change (float): Estimated precent change in terms of trade (100*[ToT&#39; - ToT]/ToT).

        baseline_imports (float): Total modeled baseline imports (consumption) including international and intranational
            flows (C_j = sum_i X_ij for all i). Based on modeled flows, not observed flows.
        baseline_exports (float): Total modeled baseline exports (shipments) including international and intranational
            flows (S_i = sum_i X_ij for all i). Based on modeled flows, not observed flows.
        experiment_imports (float): Total estimated counterfactual imports (consumption) including international and
            intranational flows (C&#39;_j = sum_i X&#39;_ij for all i).
        experiment_exports (float): Total estimated counterfactual imports (shipments) including international and
            intranational flows (S&#39;_i = sum_j X&#39;_ij for all j).

        baseline_foreign_imports (float): Total modeled baseline foreign imports (excluding intranational flows)
            (X_j = sum_i X_ij for all i!=j). Based on modeled flows, not observed flows.
        baseline_foreign_exports (float): Total modeled baseline foreign exports (excluding intranational flows)
            (X_i = sum_j X_ij for all j!=i). Based on modeled flows, not observed flows.
        experiment_foreign_imports (float): Total estimated countrefactual foreign imports (excluding intranational
            flows) (X&#39;_j = sum_i X&#39;\_ij for all i!=j).
        experiment_foreign_exports (float): Total estimated countrefactual foreign exports (excluding intranational
            flows) (X&#39;_i = sum_j X&#39;\_ij for all j!=i).
        foreign_imports_change (float): Estimated percent change in total foreign imports (100*[X&#39;_j - X_j]/X_j).
        foreign_exports_change (float): Estimated percent change in total foreign exports (100*[X&#39;_i - X_i]/X_i).

        baseline_intranational_trade (float): Baseline modeled intranational trade (X_{ii}).
        experiment_intranational_trade (float): Estimated counterfactual intranational trade (X&#39;\_{ii}).
        intranational_trade_change (float): Estimated percent change in intranational trade
            (100*[X&#39;_{ii} - X_{ii}]/X_{ii}).

        baseline_gdp (float): Baseline real GDP ($GDP_j = Y_j/P_j$).
        experiment_gdp (float): Estimated counterfactual real GDP (GDP&#39;_j = Y&#39;_j/P&#39;_j).
        gdp_change (float): Estimated percent chnage in real GDP (100*(GDP&#39; - GDP)/GDP)
        phi (float): Phi parameter for expenditure-output share (φ_i = E_i / Y_i). Based on Eqn. (30) from Larch and
            Yotov, (2016).
        welfare_stat (float) Welfare statistic based on Arkolakis et al (2012) and Yotov et al. (2016)
            ([E_i/P_i]/[E&#39;_i/P&#39;_i]).
    &#39;&#39;&#39;
    # This may need to be a country/year thing at some point
    def __init__(self,

                 identifier: str = None,
                 year: str = None,
                 baseline_output: float = None,
                 baseline_expenditure: float = None,
                 baseline_importer_fe: float = None,
                 baseline_exporter_fe: float = None,
                 reference_expenditure: float = None):

        self.identifier = identifier
        self.year = year
        self.baseline_output = baseline_output # Y_i
        self.baseline_expenditure = baseline_expenditure # E_j
        self.baseline_importer_fe = baseline_importer_fe
        self.baseline_exporter_fe = baseline_exporter_fe
        self._reference_expenditure = reference_expenditure
        self.baseline_output_share = None # Y_i/Y
        self.baseline_expenditure_share = None # E_j/Y
        # self.baseline_export_costs = None
        # self.baseline_import_costs = None
        self._baseline_imr_ratio = None  # 1 / P^{1-sigma}
        self._baseline_omr_ratio = None  # 1 / π ^{1-\sigma}
        self.baseline_imr = None  # P
        self.baseline_omr = None  # π
        self.factory_gate_price_param = None  # Beta_i
        self.baseline_factory_price = 1
        self._conditional_imr_ratio = None  # 1 / P&#39;^{1-sigma}
        self._conditional_omr_ratio = None  # 1 / π&#39;^{1-\sigma}
        self.conditional_imr = None  # P&#39;
        self.conditional_omr = None  # π&#39;
        self._experiment_imr_ratio = None  # 1 / P*^{1-sigma}
        self._experiment_omr_ratio = None  # 1 / π*^{1-\sigma}
        self.experiment_imr = None  # P*
        self.experiment_omr = None  # π*
        self.imr_change = None # 100*(P*-P)/P
        self.omr_change = None # 100*(π*-π)/π
        self.experiment_factory_price = None # p*_i
        self.experiment_output = None # Y*_i
        self.experiment_expenditure = None # E*_j
        self.baseline_terms_of_trade = None  # ToT_i = p_i/P_i
        self.experiment_terms_of_trade = None  # ToT*_i = p*_i/P*_i
        self.terms_of_trade_change = None  # 100*(ToT* - ToT)/ToT
        self.output_change = None  # 100*(Y* - Y)/Y
        self.expenditure_change = None  # 100*(E* - E)/E
        self.factory_price_change = None # 100*(p*-p)/p or, in practice, 100*(P*-1)/1
        self.baseline_imports = None  # sum_i(X_ij) [modeled flows, not observed flows]
        self.baseline_exports = None  # sum_j(X_ij) [modeled flows, not observed flows]
        self.baseline_foreign_imports = None # sum_{i!=j}(X_ij) [modeled flows, not observed flows]
        self.baseline_foreign_exports = None  # sum_{j!=i}(X_ij) [modeled flows, not observed flows]
        self.experiment_imports = None # sum_i(X*_ij)
        self.experiment_exports = None # sum_j(X*_ij)
        self.experiment_foreign_imports = None # sum_{i!=j}(X*_ij)
        self.experiment_foreign_exports = None # sum_{j!=i}(X*_ij)
        self.foreign_imports_change = None # 100*(sum_{i!=j}(X*_ij) - sum_{i!=j}(X_ij))/sum_{i!=j}(X_ij)
        self.foreign_exports_change = None # 100*(sum_{j!=i}(X*_ij) - sum_{j!=i}(X_ij))/sum_{j!=i}(X_ij)
        self.baseline_intranational_trade = None # X_ii
        self.experiment_intranational_trade = None # X*_ii
        self.intranational_trade_change = None # 100*(X*_ii - X_ii)/X_ii
        self.baseline_gdp = None # GDP_j = Y_j/P_j
        self.experiment_gdp = None # GDP*_j = Y*_j/P*_j
        self.gdp_change = None # 100*(GDP* - GDP)/GDP
        self.phi = None  # φ_i = E_i / Y_i (Eqn. (30) from Larch and Yotov, 2016)
        self.welfare_stat = None  # (E_i/P_i)/(E*_i/P*_i)


    def _calculate_baseline_output_expenditure_shares(self, economy):
        self.baseline_expenditure_share = self.baseline_expenditure / economy.baseline_total_expenditure
        self.baseline_output_share = self.baseline_output / economy.baseline_total_output

    def _construct_country_measures(self, sigma):
        for value in [self.baseline_factory_price, self._baseline_imr_ratio,
                      self.experiment_factory_price, self._experiment_imr_ratio,
                      self._conditional_imr_ratio, self._conditional_omr_ratio]:
            if value is None:
                warn(&#34;Not all necessary values for terms of trade have been calculated.&#34;)

        # Create actual values for imr (P) and omr (π) from ratio representation
        sigma_inverse = 1 / (1 - sigma)
        self.baseline_imr = 1 / (self._baseline_imr_ratio**sigma_inverse)
        self.baseline_omr = 1 / (self._baseline_omr_ratio**sigma_inverse)
        self.conditional_imr = 1 / (self._conditional_imr_ratio ** sigma_inverse)
        self.conditional_omr = 1 / (self._conditional_omr_ratio ** sigma_inverse)
        self.experiment_imr = 1 / (self._experiment_imr_ratio ** sigma_inverse)
        self.experiment_omr = 1 / (self._experiment_omr_ratio ** sigma_inverse)

        # Calculate Output and Expenditure
        self.experiment_output = self.experiment_factory_price * self.baseline_output
        self.output_change = 100 * (self.experiment_output - self.baseline_output) \
                                    / self.baseline_output
        # Experiment Expenditure: E_i = φ_i Y_i (Eqn. (30) from Larch and Yotov, 2016) -&gt;  E*_i = φ_i Y*_i
        self.phi = self.baseline_expenditure/self.baseline_output
        self.experiment_expenditure = self.phi * self.experiment_output
        self.expenditure_change = 100 * (self.experiment_expenditure -
                                                self.baseline_expenditure) / self.baseline_expenditure

        # Calculate Terms of Trade
        self.baseline_terms_of_trade = self.baseline_factory_price / self.baseline_imr
        self.experiment_terms_of_trade = self.experiment_factory_price / self.experiment_imr
        self.terms_of_trade_change = 100 * (self.experiment_terms_of_trade - self.baseline_terms_of_trade) \
                                     / self.baseline_terms_of_trade

        # Calculate GDP (from Stata code accompanying Yotov et al (2016): GDP_j = Y_j/P_j)
        self.baseline_gdp = self.baseline_output/self.baseline_imr
        self.experiment_gdp = self.experiment_output/self.experiment_imr
        self.gdp_change = 100 * (self.experiment_gdp - self.baseline_gdp)/ self.baseline_gdp

        # Calculate Arkolakis, Costinot and Rodríguez-Clare welfare statistic (Equation (25) from Larch and Yotov, 2016)
        # WF_i = W_i/W*_i = (E_i/P_i)/(E*_i/P*_i)
        self.welfare_stat = (self.baseline_expenditure/self.baseline_imr)/\
                            (self.experiment_expenditure/self.experiment_imr)

        # Calculate change in IMR (consumer price) and OMR (producer incidence) measure
        self.imr_change = 100*(self.experiment_imr - self.baseline_imr)/self.baseline_imr
        self.omr_change = 100*(self.experiment_omr - self.baseline_omr)/self.baseline_omr




    def get_results(self, labels):
        &#39;&#39;&#39;
        Collect and return the country&#39;s main results.
        Returns:
            pandas.DataFrame: A one-row dataFrame containing columns of typical results.
        &#39;&#39;&#39;
        row = pd.DataFrame(data={labels.identifier: [self.identifier],
                                 labels.factory_price_change: [self.factory_price_change],
                                 labels.omr_change: [self.omr_change],
                                 labels.imr_change: [self.imr_change],
                                 labels.gdp_change: [self.gdp_change],
                                 labels.welfare_stat: [self.welfare_stat],
                                 labels.terms_of_trade_change: [self.terms_of_trade_change],
                                 labels.output_change: [self.output_change],
                                 labels.expenditure_change: [self.expenditure_change],
                                 labels.foreign_exports_change: [self.foreign_exports_change],
                                 labels.foreign_imports_change: [self.foreign_imports_change],
                                 labels.intranational_trade_change:self.intranational_trade_change,
                                 })
        return row

    def get_mr_results(self, labels):
        &#39;&#39;&#39;
        Collect and return the country&#39;s MR terms (baseline, conditional, and experiment)
        Returns:
             pandas.DataFrame: A one-row dataFrame containing column of MR terms.
        &#39;&#39;&#39;
        row = pd.DataFrame(data={labels.identifier: [self.identifier],
                                 labels.baseline_imr: [self.baseline_imr],
                                 labels.conditional_imr: [self.conditional_imr],
                                 labels.experiment_imr: [self.experiment_imr],
                                 labels.baseline_omr: [self.baseline_omr],
                                 labels.conditional_omr: [self.conditional_omr],
                                 labels.experiment_omr: [self.experiment_omr]})
        return row

    def __repr__(self):
        return &#34;Country: {0} \n&#34; \
               &#34;Year: {1} \n&#34; \
               &#34;Baseline Output: {2} \n&#34; \
               &#34;Baseline Expenditure: {3} \n&#34; \
               &#34;Baseline IMR: {4} \n&#34; \
               &#34;Baseline OMR: {5} \n&#34; \
               &#34;Experiment IMR: {6} \n&#34; \
               &#34;Experiment OMR: {7} \n&#34; \
               &#34;Experiment Factory Price: {8} \n&#34; \
               &#34;Output Change (%): {9} \n&#34; \
               &#34;Expenditure Change (%): {10} \n&#34; \
               &#34;Terms of Trade Change (%): {11} \n&#34; \
            .format(self.identifier,
                    self.year,
                    self.baseline_output,
                    self.baseline_expenditure,
                    self.baseline_imr,
                    self.baseline_omr,
                    self.experiment_imr,
                    self.experiment_omr,
                    self.experiment_factory_price,
                    self.output_change,
                    self.expenditure_change,
                    self.terms_of_trade_change)


class _GEMetaData(object):
    &#39;&#39;&#39;
    Modified gme._MetaData object that includes output and expenditure column names
    &#39;&#39;&#39;
    def __init__(self, gme_meta_data, expend_var_name, output_var_name):
        self.imp_var_name = gme_meta_data.imp_var_name
        self.exp_var_name = gme_meta_data.exp_var_name
        self.year_var_name = gme_meta_data.year_var_name
        self.trade_var_name = gme_meta_data.trade_var_name
        self.sector_var_name = gme_meta_data.sector_var_name
        self.expend_var_name = expend_var_name
        self.output_var_name = output_var_name


class ParameterValues(object):
    def __init__(self,
             estimates:DataFrame,
                 identifier_col: str,
                 coeff_col:str,
                 stderr_col:str = None):
                 #imp_fe_prefix: str = None, # Removed until completeion of GEPPML
                 #exp_fe_prefix: str = None # Removed until completeion of GEPPML

        &#39;&#39;&#39;
        Object for supplying non-gme.EstimationModel estimates such as those from Stata, R, the literature, or any other
        source of gravity estimates.
        Args:
            estimates (pandas.DataFrame): A dataframe containing gravity model estimates, which ought to include the
                following non-optional columns.
            identifier_col (str): The name of the column containing the identifiers for each estimate. These should
                correspond to the cost variables that you will use for trade costs in the simulation. This column is
                required.
            coeff_col (str): The name of the column containing the coefficient estimates for each variable. They
                should be numeric and are required.
            stderr_col (str):  The column name for the standard error estimates for each variable. This column is only
                required for the MonteCarloGE model and may be omitted for the OneSectorGE model.

        Returns:
            ParameterValues: An instance of a ParameterValues object.
        &#39;&#39;&#39;
        # &#39;&#39;&#39;
        # imp_fe_prefix (str):  The prefix used to identify the importer fixed effects. These fixed effects and
        #         prefix are only required for the GEPPML approach in OneSectorGE.
        #     exp_fe_prefix (str):  The prefix used to identify the exporter fixed effects. These fixed effects and
        #         prefix are only required for the GEPPML approach in OneSectorGE.
        # &#39;&#39;&#39;
        estimates = estimates.set_index(identifier_col)
        # Coefficient  Estimates
        self.params = estimates[coeff_col].copy()
        # Standard error estimates
        if stderr_col is not None:
            self.bse = estimates[stderr_col].copy()
        else:
            self.bse = None

        # self.imp_fe_prefix = imp_fe_prefix
        # self.exp_fe_prefix = exp_fe_prefix



class ResultsLabels(object):
    &#34;&#34;&#34;
    Labels and definitions used in results outputs:

    # Bilateral Trade Results

        \n **baseline modeled trade**: Trade constructed using estimated baseline trade costs and multilateral
            resistances (X\_{ij}).
        \n**experiment trade**: Counterfactual experiment trade constructed using experiment trade costs and GE
        experiment multilateral resistances (X&#39;\_{ij}).
        \n**trade change (percent)**: Estimated percent change in bilateral trade (100*[X&#39;\_{ij} - X\_{ij}]/X\_{ij})
        \n**trade change (observed level)**: Estimated change in trade values using observed trade in the source
        sample. (i.e. estimated trade change times observed values)
        \n**baseline observed trade**: Observed trade values. (Not necessarily equivalent to modeled values.)
        \n**experiment observed trade**: Estiamted counterfactual trade values based on predicted change and observed
        baseline values. (Not necessarily equivalent to modeled values.)

    # Country level Results
        \n **country**: Country identifier.
        \n **factory gate price change (percent)**: Estimated percent change in factory gate prices.
        \n **experiment factory gate price**: Experiment factory gate prices (P_i). Baseline prices are all set to 1.
        \n **terms of trade change (percent)**: Percent change in the terms of trade. Terms of trade defined as factory
            gate price (p_i) divided by inward multilateral resistance (P_i). Measures changes in output prices relative
            to consumption prices. Increases imply greater purchasing power (income growth relative to consumption
            costs), decreases imply lower purchasing power.
        \n **GDP change (percent)**: Percent change in GDP, which is calculated as output (Y_i) divided by factory gate
            prices (p_i)
        \n **welfare statistic**: Welfare statistic form Arkolakis et al. (2012) and Yotov et al. (2016). Defined as
            (E_i/P_i)/(E&#39;_i/P&#39;_i) where E_i denotes expenditure, P_i denotes inward multilateral resistance, and &#39; denotes
            the experiment estimates.
        \n **baseline output**: User supplied baseline output (Y_i).
        \n **experiment output**: Experiment estimated output (Y&#39;_i).
        \n **output change (percent)**: Estimated percent change in output (100*[Y&#39;_i - Y_i]/Y_i).
        \n **baseline expenditure**: User supplied baseline expenditure (E_i).
        \n **experiment expenditure**: Experiment estimated expenditure (E&#39;_i).
        \n **expenditure change (percent)**: Estimated percent change in expenditure (100*[E&#39;_i - E_i]/E_i).
        \n **baseline modeled shipments**: Modeled baseline aggregate exports including both domestic and international
            flows (S_i = sum_j X_{ij} for all j).
        \n **experiment shipments**: Estimated experiment aggregate exports including both domestic and international
            flows (S&#39;_i = sum_j X&#39;\_{ij} for all j).
        \n **shipments change (percent)**: Estimated percent change in total shipments (100*[S&#39;_i -
            S_i]/S_i)
        \n **baseline modeled consumption**: Modeled baseline aggregate imports including both intranational and
            international flows (C_j = sum_i X_{ij} for all i).
        \n **experiment consumption**: Estimated experiment aggregate imports including both intranational and
            international flows (C&#39;\_j = sum_i X&#39;_{ij} for all i).
        \n **consumption change (percent)**: Estimated percent change in total consumption
            (100*[C&#39;_j - C_j]/C_j)
        \n **baseline modeled foreign exports**: Modeled baseline aggregate exports, international flows only.
            (X_i = sum_j X_{ij} for all j!=i)
        \n **experiment foreign exports**: Estimated experiment aggregate exports, international flows only.
            (X&#39;_i = sum_j X&#39;\_{ij} for all j!=i)
        \n **foreign exports change (percent)**: Estimated percent change in aggregate foreign exports (100*[X&#39;_i - X_i]
            /X_i).
        \n **baseline observed foreign exports**: Total foreign exports based on observed rather than modeled baseline
            values.
        \n **baseline modeled foreign imports**: Modeled baseline aggregate imports, international flows only.
            (X_j = sum_i X_{ij} for all i!=j)
        \n **experiment foreign imports**: Estimated experiment aggregate imports, international flows only.
            (X_j = sum_i X_{ij} for all i!=j)
        \n **foreign imports change (percent)**: Estimated percent change in aggregate foreign imports (100*[X&#39;_j - X_j]
            /X_j).
        \n **baseline observed foreign imports**: Total foreign imports based on observed rather than modeled baseline
            values.
        \n **baseline modeled intranational trade**: Modeled baseline intranational (domestic) trade flows (X_{ii}).
        \n **experiment modeled intranational trade**: Estimated experiment intranational (domestic) trade flows
            (X&#39;\_{ii}).
        \n **intranational trade change (percent)**: Estimated percent change in intranational (domestic) trade flows
            (100*[X&#39;\_{ii} - X_{ii}]/X_{ii})
        \n **baseline observed intranational trade**: Intranational trade flows based on observed values rather than
            modeled baseline values.
        \n **baseline imr**: Baseline constructed inward multilateral resistance terms (P_j). P_j = 1 for the selected
            reference importer.
        \n **conditional imr**: Partial equilibrium (&#39;conditional&#39;) estimates of the inward multilateral resistance
            terms.
        \n **experiment imr**: Full equilibrium estimates for the counterfactual experiment inward multilateral
            resistance terms (P&#39;\_j). P&#39;\_j = 1 for the selected reference importer.
        \n **imr change (percent)**: Estimated percent change in inward multilateral resistances
            (100*[P&#39;\_j - P_j]/P_j).
        \n **baseline omr**: Baseline constructed outward multilateral resistance terms (π_i).
        \n **conditional omr**: Partial equilibrium (&#39;conditional&#39;) estimates of the outward multilateral resistance
            terms.
        \n **experiment omr**: Full equilibrium estimates for the counterfactual experiment outward multilateral
            resistance terms (π&#39;\_i).
        \n **omr change (percent)**: Estimated percent change in outward multilateral resistances
            (100*[π&#39;\_i - π_i]/π_i).

    &#34;&#34;&#34;
    def __init__(self):
        # Trade Labels (bilateral)
        self.baseline_modeled_trade = &#39;baseline modeled trade&#39;
        self.experiment_trade = &#39;experiment trade&#39;
        self.trade_change = &#39;trade change (percent)&#39;
        self.trade_change_level = &#39;trade change (observed level)&#39;
        self.baseline_observed_trade = &#39;baseline observed trade&#39;
        self.experiment_observed_trade = &#39;experiment observed trade&#39;

        # Country level
        self.identifier= &#39;country&#39;
        self.factory_price_change= &#39;factory gate price change (percent)&#39;
        self.experiment_factory_price= &#39;experiment factory gate price&#39;
        self.terms_of_trade_change = &#39;terms of trade change (percent)&#39;
        self.gdp_change = &#34;GDP change (percent)&#34;
        self.welfare_stat = &#39;welfare statistic&#39;
        self.baseline_output = &#39;baseline output&#39;
        self.experiment_output = &#39;experiment output&#39;
        self.output_change = &#39;output change (percent)&#39;
        self.baseline_expenditure = &#39;baseline expenditure&#39;
        self.experiment_expenditure = &#39;experiment expenditure&#39;
        self.expenditure_change = &#39;expenditure change (percent)&#39;
        self.baseline_exports = &#39;baseline modeled shipments&#39;
        self.experiment_exports = &#39;experiment shipments&#39;
        self.exports_change = &#39;shipments change (percent)&#39;
        self.baseline_imports = &#39;baseline modeled consumption&#39;
        self.experiment_imports = &#39;experiment consumption&#39;
        self.imports_change = &#39;consumption change (percent)&#39;
        self.baseline_foreign_exports = &#39;baseline modeled foreign exports&#39;
        self.experiment_foreign_exports = &#39;experiment foreign exports&#39;
        self.foreign_exports_change = &#39;foreign exports change (percent)&#39;
        self.baseline_observed_foreign_exports = &#39;baseline observed foreign exports&#39;
        self.baseline_foreign_imports = &#39;baseline modeled foreign imports&#39;
        self.experiment_foreign_imports = &#39;experiment foreign imports&#39;
        self.foreign_imports_change = &#39;foreign imports change (percent)&#39;
        self.baseline_observed_foreign_imports = &#39;baseline observed foreign imports&#39;
        self.baseline_intranational_trade = &#39;baseline modeled intranational trade&#39;
        self.experiment_intranational_trade = &#39;experiment modeled intranational trade&#39;
        self.intranational_trade_change = &#39;intranational trade change (percent)&#39;
        self.baseline_observed_intranational_trade = &#39;baseline observed intranational trade&#39;
        self.baseline_imr = &#39;baseline imr&#39;
        self.conditional_imr = &#39;conditional imr&#39;
        self.experiment_imr = &#39;experiment imr&#39;
        self.imr_change = &#39;imr change (percent)&#39;
        self.baseline_omr = &#39;baseline omr&#39;
        self.conditional_omr = &#39;conditional omr&#39;
        self.experiment_omr = &#39;experiment omr&#39;
        self.omr_change = &#39;omr change (percent)&#39;

        # Get a set of country-level results by excluding the bilateral ones
        self.bilat_labels = [self.baseline_modeled_trade, self.experiment_trade, self.trade_change,
                             self.trade_change_level, self.baseline_observed_trade, self.experiment_observed_trade]

        # Create a list of Country-level labels to include in results
        self.country_level_labels = [self.identifier,
                        self.factory_price_change,
                        self.baseline_imr, self.experiment_imr, self.imr_change,
                        self.baseline_omr, self.experiment_omr, self.omr_change,
                        self.terms_of_trade_change, self.gdp_change, self.welfare_stat,
                        self.baseline_output, self.experiment_output, self.output_change,
                        self.baseline_expenditure, self.experiment_expenditure, self.expenditure_change,
                        self.baseline_foreign_exports, self.experiment_foreign_exports,
                        self.foreign_exports_change, self.baseline_observed_foreign_exports,
                        self.baseline_foreign_imports, self.experiment_foreign_imports,
                        self.foreign_imports_change, self.baseline_observed_foreign_imports,
                        self.baseline_intranational_trade, self.experiment_intranational_trade,
                        self.intranational_trade_change, self.baseline_observed_intranational_trade]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="models.OneSectorGE.Country"><code class="flex name class">
<span>class <span class="ident">Country</span></span>
<span>(</span><span>identifier: str = None, year: str = None, baseline_output: float = None, baseline_expenditure: float = None, baseline_importer_fe: float = None, baseline_exporter_fe: float = None, reference_expenditure: float = None)</span>
</code></dt>
<dd>
<div class="desc"><p>An object for housing country-level information</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>identifier</code></strong> :&ensp;<code>str</code></dt>
<dd>Country name or identifier.</dd>
<dt><strong><code>year</code></strong> :&ensp;<code>str</code></dt>
<dd>The year used for analysis.</dd>
<dt><strong><code>baseline_output</code></strong> :&ensp;<code>float</code></dt>
<dd>User supplied baseline output ($Y_i$).</dd>
<dt><strong><code>baseline_output_share</code></strong> :&ensp;<code>float</code></dt>
<dd>Share of country output in total world outpur (Y_i/Y).</dd>
<dt><strong><code>experiment_output</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimated counterfactual output (Y'_i).</dd>
<dt><strong><code>output_change</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimated percent change in output (100*[Y' - Y]/Y).</dd>
<dt><strong><code>baseline_expenditure</code></strong> :&ensp;<code>float</code></dt>
<dd>User supplied baseline expenditure (E_j).</dd>
<dt><strong><code>baseline_expenditure_share</code></strong> :&ensp;<code>float</code></dt>
<dd>Share of country expenditure in total world expenditure (E_j/E).</dd>
<dt><strong><code>experiment_expenditure</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimated counterfctual expenditure (E'_j).</dd>
<dt><strong><code>expenditure_change</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimated percent change in expenditure (100*[E' - E]/E).</dd>
<dt><strong><code>baseline_importer_fe</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimated importer or importer-year fixed effect, if supplied in estimation model.</dd>
<dt><strong><code>baseline_exporter_fe</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimated exporter or exporter-year fixed effect, if supplied in estimation model.</dd>
<dt><strong><code>baseline_imr</code></strong> :&ensp;<code>float</code></dt>
<dd>Baseline inward multilateral resistance term (P_j).</dd>
<dt><strong><code>conditional_imr</code></strong> :&ensp;<code>float</code></dt>
<dd>Conditional (partial) equilibrium counterfactual experiment inward multilateral
resistance term.</dd>
<dt><strong><code>experiment_imr</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimated full GE, counterfactual inward multilateral resistance term (P'_j).</dd>
<dt><strong><code>imr_change</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimated percent change in inward multilateral resistance term (100*[P'-P]/P).</dd>
<dt><strong><code>baseline_omr</code></strong> :&ensp;<code>float</code></dt>
<dd>Baseline outward multilateral resistance term (π_i).</dd>
<dt><strong><code>conditional_omr</code></strong> :&ensp;<code>float</code></dt>
<dd>Conditional (partial) equilibrium counterfactual experiment outward multilateral
resistance term.</dd>
<dt><strong><code>experiment_omr</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimated full GE, counterfactual outward multilateral resistance term (π'_i).</dd>
<dt><strong><code>omr_change</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimated percent change in inward multilateral resistance term (100*[π'-π]/π).</dd>
<dt><strong><code>factory_gate_price_param</code></strong> :&ensp;<code>float</code></dt>
<dd>Calibrated factory gate price parameter (ß_i).</dd>
<dt><strong><code>baseline_factory_price</code></strong> :&ensp;<code>float</code></dt>
<dd>Baseline factory gate price (p_i), normalized to 1 by construction.</dd>
<dt><strong><code>experiment_factory_price</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimated counterfactual factory gate price (p'_i).</dd>
<dt><strong><code>factory_price_change</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimated percent change in factory gate prices (100<em>[p</em>-p]/p).</dd>
<dt><strong><code>baseline_terms_of_trade</code></strong> :&ensp;<code>float</code></dt>
<dd>Baseline terms of trade (ToT_i = p_i/P_i).</dd>
<dt><strong><code>experiment_terms_of_trade</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimated counterfactual terms of trade (ToT'_i = p'_i/P'_i).</dd>
<dt><strong><code>terms_of_trade_change</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimated precent change in terms of trade (100*[ToT' - ToT]/ToT).</dd>
<dt><strong><code>baseline_imports</code></strong> :&ensp;<code>float</code></dt>
<dd>Total modeled baseline imports (consumption) including international and intranational
flows (C_j = sum_i X_ij for all i). Based on modeled flows, not observed flows.</dd>
<dt><strong><code>baseline_exports</code></strong> :&ensp;<code>float</code></dt>
<dd>Total modeled baseline exports (shipments) including international and intranational
flows (S_i = sum_i X_ij for all i). Based on modeled flows, not observed flows.</dd>
<dt><strong><code>experiment_imports</code></strong> :&ensp;<code>float</code></dt>
<dd>Total estimated counterfactual imports (consumption) including international and
intranational flows (C'_j = sum_i X'_ij for all i).</dd>
<dt><strong><code>experiment_exports</code></strong> :&ensp;<code>float</code></dt>
<dd>Total estimated counterfactual imports (shipments) including international and
intranational flows (S'_i = sum_j X'_ij for all j).</dd>
<dt><strong><code>baseline_foreign_imports</code></strong> :&ensp;<code>float</code></dt>
<dd>Total modeled baseline foreign imports (excluding intranational flows)
(X_j = sum_i X_ij for all i!=j). Based on modeled flows, not observed flows.</dd>
<dt><strong><code>baseline_foreign_exports</code></strong> :&ensp;<code>float</code></dt>
<dd>Total modeled baseline foreign exports (excluding intranational flows)
(X_i = sum_j X_ij for all j!=i). Based on modeled flows, not observed flows.</dd>
<dt><strong><code>experiment_foreign_imports</code></strong> :&ensp;<code>float</code></dt>
<dd>Total estimated countrefactual foreign imports (excluding intranational
flows) (X'_j = sum_i X'_ij for all i!=j).</dd>
<dt><strong><code>experiment_foreign_exports</code></strong> :&ensp;<code>float</code></dt>
<dd>Total estimated countrefactual foreign exports (excluding intranational
flows) (X'_i = sum_j X'_ij for all j!=i).</dd>
<dt><strong><code>foreign_imports_change</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimated percent change in total foreign imports (100*[X'_j - X_j]/X_j).</dd>
<dt><strong><code>foreign_exports_change</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimated percent change in total foreign exports (100*[X'_i - X_i]/X_i).</dd>
<dt><strong><code>baseline_intranational_trade</code></strong> :&ensp;<code>float</code></dt>
<dd>Baseline modeled intranational trade (X_{ii}).</dd>
<dt><strong><code>experiment_intranational_trade</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimated counterfactual intranational trade (X'_{ii}).</dd>
<dt><strong><code>intranational_trade_change</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimated percent change in intranational trade
(100*[X'<em ii>{ii} - X</em>]/X_{ii}).</dd>
<dt><strong><code>baseline_gdp</code></strong> :&ensp;<code>float</code></dt>
<dd>Baseline real GDP ($GDP_j = Y_j/P_j$).</dd>
<dt><strong><code>experiment_gdp</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimated counterfactual real GDP (GDP'_j = Y'_j/P'_j).</dd>
<dt><strong><code>gdp_change</code></strong> :&ensp;<code>float</code></dt>
<dd>Estimated percent chnage in real GDP (100*(GDP' - GDP)/GDP)</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>float</code></dt>
<dd>Phi parameter for expenditure-output share (φ_i = E_i / Y_i). Based on Eqn. (30) from Larch and
Yotov, (2016).</dd>
</dl>
<p>welfare_stat (float) Welfare statistic based on Arkolakis et al (2012) and Yotov et al. (2016)
([E_i/P_i]/[E'_i/P'_i]).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Country(object):
    &#39;&#39;&#39;
    An object for housing country-level information

    Attributes:
        identifier (str): Country name or identifier.
        year (str): The year used for analysis.
        baseline_output (float): User supplied baseline output ($Y_i$).
        baseline_output_share (float): Share of country output in total world outpur (Y_i/Y).
        experiment_output (float): Estimated counterfactual output (Y&#39;_i).
        output_change (float): Estimated percent change in output (100*[Y&#39; - Y]/Y).
        baseline_expenditure (float): User supplied baseline expenditure (E_j).
        baseline_expenditure_share (float): Share of country expenditure in total world expenditure (E_j/E).
        experiment_expenditure (float): Estimated counterfctual expenditure (E&#39;_j).
        expenditure_change (float): Estimated percent change in expenditure (100*[E&#39; - E]/E).
        baseline_importer_fe (float): Estimated importer or importer-year fixed effect, if supplied in estimation model.
        baseline_exporter_fe (float): Estimated exporter or exporter-year fixed effect, if supplied in estimation model.

        baseline_imr (float): Baseline inward multilateral resistance term (P_j).
        conditional_imr (float): Conditional (partial) equilibrium counterfactual experiment inward multilateral
            resistance term.
        experiment_imr (float): Estimated full GE, counterfactual inward multilateral resistance term (P&#39;\_j).
        imr_change (float): Estimated percent change in inward multilateral resistance term (100*[P&#39;-P]/P).

        baseline_omr (float): Baseline outward multilateral resistance term (π_i).
        conditional_omr (float): Conditional (partial) equilibrium counterfactual experiment outward multilateral
            resistance term.
        experiment_omr (float): Estimated full GE, counterfactual outward multilateral resistance term (π&#39;\_i).
        omr_change (float): Estimated percent change in inward multilateral resistance term (100*[π&#39;-π]/π).

        factory_gate_price_param (float): Calibrated factory gate price parameter (ß_i).
        baseline_factory_price (float): Baseline factory gate price (p_i), normalized to 1 by construction.
        experiment_factory_price (float): Estimated counterfactual factory gate price (p&#39;_i).
        factory_price_change (float): Estimated percent change in factory gate prices (100*[p*-p]/p).

        baseline_terms_of_trade (float): Baseline terms of trade (ToT_i = p_i/P_i).
        experiment_terms_of_trade (float): Estimated counterfactual terms of trade (ToT&#39;_i = p&#39;_i/P&#39;_i).
        terms_of_trade_change (float): Estimated precent change in terms of trade (100*[ToT&#39; - ToT]/ToT).

        baseline_imports (float): Total modeled baseline imports (consumption) including international and intranational
            flows (C_j = sum_i X_ij for all i). Based on modeled flows, not observed flows.
        baseline_exports (float): Total modeled baseline exports (shipments) including international and intranational
            flows (S_i = sum_i X_ij for all i). Based on modeled flows, not observed flows.
        experiment_imports (float): Total estimated counterfactual imports (consumption) including international and
            intranational flows (C&#39;_j = sum_i X&#39;_ij for all i).
        experiment_exports (float): Total estimated counterfactual imports (shipments) including international and
            intranational flows (S&#39;_i = sum_j X&#39;_ij for all j).

        baseline_foreign_imports (float): Total modeled baseline foreign imports (excluding intranational flows)
            (X_j = sum_i X_ij for all i!=j). Based on modeled flows, not observed flows.
        baseline_foreign_exports (float): Total modeled baseline foreign exports (excluding intranational flows)
            (X_i = sum_j X_ij for all j!=i). Based on modeled flows, not observed flows.
        experiment_foreign_imports (float): Total estimated countrefactual foreign imports (excluding intranational
            flows) (X&#39;_j = sum_i X&#39;\_ij for all i!=j).
        experiment_foreign_exports (float): Total estimated countrefactual foreign exports (excluding intranational
            flows) (X&#39;_i = sum_j X&#39;\_ij for all j!=i).
        foreign_imports_change (float): Estimated percent change in total foreign imports (100*[X&#39;_j - X_j]/X_j).
        foreign_exports_change (float): Estimated percent change in total foreign exports (100*[X&#39;_i - X_i]/X_i).

        baseline_intranational_trade (float): Baseline modeled intranational trade (X_{ii}).
        experiment_intranational_trade (float): Estimated counterfactual intranational trade (X&#39;\_{ii}).
        intranational_trade_change (float): Estimated percent change in intranational trade
            (100*[X&#39;_{ii} - X_{ii}]/X_{ii}).

        baseline_gdp (float): Baseline real GDP ($GDP_j = Y_j/P_j$).
        experiment_gdp (float): Estimated counterfactual real GDP (GDP&#39;_j = Y&#39;_j/P&#39;_j).
        gdp_change (float): Estimated percent chnage in real GDP (100*(GDP&#39; - GDP)/GDP)
        phi (float): Phi parameter for expenditure-output share (φ_i = E_i / Y_i). Based on Eqn. (30) from Larch and
            Yotov, (2016).
        welfare_stat (float) Welfare statistic based on Arkolakis et al (2012) and Yotov et al. (2016)
            ([E_i/P_i]/[E&#39;_i/P&#39;_i]).
    &#39;&#39;&#39;
    # This may need to be a country/year thing at some point
    def __init__(self,

                 identifier: str = None,
                 year: str = None,
                 baseline_output: float = None,
                 baseline_expenditure: float = None,
                 baseline_importer_fe: float = None,
                 baseline_exporter_fe: float = None,
                 reference_expenditure: float = None):

        self.identifier = identifier
        self.year = year
        self.baseline_output = baseline_output # Y_i
        self.baseline_expenditure = baseline_expenditure # E_j
        self.baseline_importer_fe = baseline_importer_fe
        self.baseline_exporter_fe = baseline_exporter_fe
        self._reference_expenditure = reference_expenditure
        self.baseline_output_share = None # Y_i/Y
        self.baseline_expenditure_share = None # E_j/Y
        # self.baseline_export_costs = None
        # self.baseline_import_costs = None
        self._baseline_imr_ratio = None  # 1 / P^{1-sigma}
        self._baseline_omr_ratio = None  # 1 / π ^{1-\sigma}
        self.baseline_imr = None  # P
        self.baseline_omr = None  # π
        self.factory_gate_price_param = None  # Beta_i
        self.baseline_factory_price = 1
        self._conditional_imr_ratio = None  # 1 / P&#39;^{1-sigma}
        self._conditional_omr_ratio = None  # 1 / π&#39;^{1-\sigma}
        self.conditional_imr = None  # P&#39;
        self.conditional_omr = None  # π&#39;
        self._experiment_imr_ratio = None  # 1 / P*^{1-sigma}
        self._experiment_omr_ratio = None  # 1 / π*^{1-\sigma}
        self.experiment_imr = None  # P*
        self.experiment_omr = None  # π*
        self.imr_change = None # 100*(P*-P)/P
        self.omr_change = None # 100*(π*-π)/π
        self.experiment_factory_price = None # p*_i
        self.experiment_output = None # Y*_i
        self.experiment_expenditure = None # E*_j
        self.baseline_terms_of_trade = None  # ToT_i = p_i/P_i
        self.experiment_terms_of_trade = None  # ToT*_i = p*_i/P*_i
        self.terms_of_trade_change = None  # 100*(ToT* - ToT)/ToT
        self.output_change = None  # 100*(Y* - Y)/Y
        self.expenditure_change = None  # 100*(E* - E)/E
        self.factory_price_change = None # 100*(p*-p)/p or, in practice, 100*(P*-1)/1
        self.baseline_imports = None  # sum_i(X_ij) [modeled flows, not observed flows]
        self.baseline_exports = None  # sum_j(X_ij) [modeled flows, not observed flows]
        self.baseline_foreign_imports = None # sum_{i!=j}(X_ij) [modeled flows, not observed flows]
        self.baseline_foreign_exports = None  # sum_{j!=i}(X_ij) [modeled flows, not observed flows]
        self.experiment_imports = None # sum_i(X*_ij)
        self.experiment_exports = None # sum_j(X*_ij)
        self.experiment_foreign_imports = None # sum_{i!=j}(X*_ij)
        self.experiment_foreign_exports = None # sum_{j!=i}(X*_ij)
        self.foreign_imports_change = None # 100*(sum_{i!=j}(X*_ij) - sum_{i!=j}(X_ij))/sum_{i!=j}(X_ij)
        self.foreign_exports_change = None # 100*(sum_{j!=i}(X*_ij) - sum_{j!=i}(X_ij))/sum_{j!=i}(X_ij)
        self.baseline_intranational_trade = None # X_ii
        self.experiment_intranational_trade = None # X*_ii
        self.intranational_trade_change = None # 100*(X*_ii - X_ii)/X_ii
        self.baseline_gdp = None # GDP_j = Y_j/P_j
        self.experiment_gdp = None # GDP*_j = Y*_j/P*_j
        self.gdp_change = None # 100*(GDP* - GDP)/GDP
        self.phi = None  # φ_i = E_i / Y_i (Eqn. (30) from Larch and Yotov, 2016)
        self.welfare_stat = None  # (E_i/P_i)/(E*_i/P*_i)


    def _calculate_baseline_output_expenditure_shares(self, economy):
        self.baseline_expenditure_share = self.baseline_expenditure / economy.baseline_total_expenditure
        self.baseline_output_share = self.baseline_output / economy.baseline_total_output

    def _construct_country_measures(self, sigma):
        for value in [self.baseline_factory_price, self._baseline_imr_ratio,
                      self.experiment_factory_price, self._experiment_imr_ratio,
                      self._conditional_imr_ratio, self._conditional_omr_ratio]:
            if value is None:
                warn(&#34;Not all necessary values for terms of trade have been calculated.&#34;)

        # Create actual values for imr (P) and omr (π) from ratio representation
        sigma_inverse = 1 / (1 - sigma)
        self.baseline_imr = 1 / (self._baseline_imr_ratio**sigma_inverse)
        self.baseline_omr = 1 / (self._baseline_omr_ratio**sigma_inverse)
        self.conditional_imr = 1 / (self._conditional_imr_ratio ** sigma_inverse)
        self.conditional_omr = 1 / (self._conditional_omr_ratio ** sigma_inverse)
        self.experiment_imr = 1 / (self._experiment_imr_ratio ** sigma_inverse)
        self.experiment_omr = 1 / (self._experiment_omr_ratio ** sigma_inverse)

        # Calculate Output and Expenditure
        self.experiment_output = self.experiment_factory_price * self.baseline_output
        self.output_change = 100 * (self.experiment_output - self.baseline_output) \
                                    / self.baseline_output
        # Experiment Expenditure: E_i = φ_i Y_i (Eqn. (30) from Larch and Yotov, 2016) -&gt;  E*_i = φ_i Y*_i
        self.phi = self.baseline_expenditure/self.baseline_output
        self.experiment_expenditure = self.phi * self.experiment_output
        self.expenditure_change = 100 * (self.experiment_expenditure -
                                                self.baseline_expenditure) / self.baseline_expenditure

        # Calculate Terms of Trade
        self.baseline_terms_of_trade = self.baseline_factory_price / self.baseline_imr
        self.experiment_terms_of_trade = self.experiment_factory_price / self.experiment_imr
        self.terms_of_trade_change = 100 * (self.experiment_terms_of_trade - self.baseline_terms_of_trade) \
                                     / self.baseline_terms_of_trade

        # Calculate GDP (from Stata code accompanying Yotov et al (2016): GDP_j = Y_j/P_j)
        self.baseline_gdp = self.baseline_output/self.baseline_imr
        self.experiment_gdp = self.experiment_output/self.experiment_imr
        self.gdp_change = 100 * (self.experiment_gdp - self.baseline_gdp)/ self.baseline_gdp

        # Calculate Arkolakis, Costinot and Rodríguez-Clare welfare statistic (Equation (25) from Larch and Yotov, 2016)
        # WF_i = W_i/W*_i = (E_i/P_i)/(E*_i/P*_i)
        self.welfare_stat = (self.baseline_expenditure/self.baseline_imr)/\
                            (self.experiment_expenditure/self.experiment_imr)

        # Calculate change in IMR (consumer price) and OMR (producer incidence) measure
        self.imr_change = 100*(self.experiment_imr - self.baseline_imr)/self.baseline_imr
        self.omr_change = 100*(self.experiment_omr - self.baseline_omr)/self.baseline_omr




    def get_results(self, labels):
        &#39;&#39;&#39;
        Collect and return the country&#39;s main results.
        Returns:
            pandas.DataFrame: A one-row dataFrame containing columns of typical results.
        &#39;&#39;&#39;
        row = pd.DataFrame(data={labels.identifier: [self.identifier],
                                 labels.factory_price_change: [self.factory_price_change],
                                 labels.omr_change: [self.omr_change],
                                 labels.imr_change: [self.imr_change],
                                 labels.gdp_change: [self.gdp_change],
                                 labels.welfare_stat: [self.welfare_stat],
                                 labels.terms_of_trade_change: [self.terms_of_trade_change],
                                 labels.output_change: [self.output_change],
                                 labels.expenditure_change: [self.expenditure_change],
                                 labels.foreign_exports_change: [self.foreign_exports_change],
                                 labels.foreign_imports_change: [self.foreign_imports_change],
                                 labels.intranational_trade_change:self.intranational_trade_change,
                                 })
        return row

    def get_mr_results(self, labels):
        &#39;&#39;&#39;
        Collect and return the country&#39;s MR terms (baseline, conditional, and experiment)
        Returns:
             pandas.DataFrame: A one-row dataFrame containing column of MR terms.
        &#39;&#39;&#39;
        row = pd.DataFrame(data={labels.identifier: [self.identifier],
                                 labels.baseline_imr: [self.baseline_imr],
                                 labels.conditional_imr: [self.conditional_imr],
                                 labels.experiment_imr: [self.experiment_imr],
                                 labels.baseline_omr: [self.baseline_omr],
                                 labels.conditional_omr: [self.conditional_omr],
                                 labels.experiment_omr: [self.experiment_omr]})
        return row

    def __repr__(self):
        return &#34;Country: {0} \n&#34; \
               &#34;Year: {1} \n&#34; \
               &#34;Baseline Output: {2} \n&#34; \
               &#34;Baseline Expenditure: {3} \n&#34; \
               &#34;Baseline IMR: {4} \n&#34; \
               &#34;Baseline OMR: {5} \n&#34; \
               &#34;Experiment IMR: {6} \n&#34; \
               &#34;Experiment OMR: {7} \n&#34; \
               &#34;Experiment Factory Price: {8} \n&#34; \
               &#34;Output Change (%): {9} \n&#34; \
               &#34;Expenditure Change (%): {10} \n&#34; \
               &#34;Terms of Trade Change (%): {11} \n&#34; \
            .format(self.identifier,
                    self.year,
                    self.baseline_output,
                    self.baseline_expenditure,
                    self.baseline_imr,
                    self.baseline_omr,
                    self.experiment_imr,
                    self.experiment_omr,
                    self.experiment_factory_price,
                    self.output_change,
                    self.expenditure_change,
                    self.terms_of_trade_change)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="models.OneSectorGE.Country.get_mr_results"><code class="name flex">
<span>def <span class="ident">get_mr_results</span></span>(<span>self, labels)</span>
</code></dt>
<dd>
<div class="desc"><p>Collect and return the country's MR terms (baseline, conditional, and experiment)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>A one-row dataFrame containing column of MR terms.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mr_results(self, labels):
    &#39;&#39;&#39;
    Collect and return the country&#39;s MR terms (baseline, conditional, and experiment)
    Returns:
         pandas.DataFrame: A one-row dataFrame containing column of MR terms.
    &#39;&#39;&#39;
    row = pd.DataFrame(data={labels.identifier: [self.identifier],
                             labels.baseline_imr: [self.baseline_imr],
                             labels.conditional_imr: [self.conditional_imr],
                             labels.experiment_imr: [self.experiment_imr],
                             labels.baseline_omr: [self.baseline_omr],
                             labels.conditional_omr: [self.conditional_omr],
                             labels.experiment_omr: [self.experiment_omr]})
    return row</code></pre>
</details>
</dd>
<dt id="models.OneSectorGE.Country.get_results"><code class="name flex">
<span>def <span class="ident">get_results</span></span>(<span>self, labels)</span>
</code></dt>
<dd>
<div class="desc"><p>Collect and return the country's main results.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>A one-row dataFrame containing columns of typical results.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_results(self, labels):
    &#39;&#39;&#39;
    Collect and return the country&#39;s main results.
    Returns:
        pandas.DataFrame: A one-row dataFrame containing columns of typical results.
    &#39;&#39;&#39;
    row = pd.DataFrame(data={labels.identifier: [self.identifier],
                             labels.factory_price_change: [self.factory_price_change],
                             labels.omr_change: [self.omr_change],
                             labels.imr_change: [self.imr_change],
                             labels.gdp_change: [self.gdp_change],
                             labels.welfare_stat: [self.welfare_stat],
                             labels.terms_of_trade_change: [self.terms_of_trade_change],
                             labels.output_change: [self.output_change],
                             labels.expenditure_change: [self.expenditure_change],
                             labels.foreign_exports_change: [self.foreign_exports_change],
                             labels.foreign_imports_change: [self.foreign_imports_change],
                             labels.intranational_trade_change:self.intranational_trade_change,
                             })
    return row</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="models.OneSectorGE.Economy"><code class="flex name class">
<span>class <span class="ident">Economy</span></span>
<span>(</span><span>sigma: float = 4)</span>
</code></dt>
<dd>
<div class="desc"><p>Object for storing economy-wide information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Economy(object):
    &#39;&#39;&#39;
    Object for storing economy-wide information.
    &#39;&#39;&#39;
    def __init__(self,
                 sigma: float = 4):
        self.sigma = sigma
        self.experiment_total_output = None
        self.experiment_total_expenditure = None
        self.baseline_total_output = None
        self.baseline_total_expenditure = None
        self.output_change = None

    def _initialize_baseline_total_output_expend(self, country_set):
        # Create baseline values for total output and expenditure
        total_output = 0
        total_expenditure = 0
        for country in country_set.keys():
            total_output += country_set[country].baseline_output
            total_expenditure += country_set[country].baseline_expenditure
        self.baseline_total_output = total_output
        self.baseline_total_expenditure = total_expenditure

    def __repr__(self):
        return &#34;Economy \n&#34; \
               &#34;Sigma: {0} \n&#34; \
               &#34;Baseline Total Output: {1} \n&#34; \
               &#34;Baseline Total Expenditure: {2} \n&#34; \
               &#34;Experiment Total Output: {3} \n&#34; \
               &#34;Output Change (%): {4} \n&#34; \
            .format(self.sigma,
                    self.baseline_total_output,
                    self.baseline_total_expenditure,
                    self.experiment_total_output,
                    self.output_change)</code></pre>
</details>
</dd>
<dt id="models.OneSectorGE.OneSectorGE"><code class="flex name class">
<span>class <span class="ident">OneSectorGE</span></span>
<span>(</span><span>estimation_model: gme.estimate.EstimationModel.EstimationModel, year: str, reference_importer: str, expend_var_name: str = 'expenditure', output_var_name: str = 'output', sigma: float = 5, results_key: str = 'all', cost_variables: List[str] = None, parameter_values=None, quiet: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Define a general equilibrium (GE) gravity model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>estimation_model</code></strong> :&ensp;<code>gme.EstimationModel</code></dt>
<dd>A GME Estimation model</dd>
<dt><strong><code>year</code></strong> :&ensp;<code>str</code></dt>
<dd>The year to be used for the model. Works best if estimation_model year column has been cast as
string too.</dd>
<dt><strong><code>reference_importer</code></strong> :&ensp;<code>str</code></dt>
<dd>Identifier for the country to be used as the reference importer (inward
multilateral resistance normalized to 1 and other multilateral resistances solved relative to it).</dd>
<dt><strong><code>expend_var_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Column name of variable containing expenditure data in estimation_model.</dd>
<dt><strong><code>output_var_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Column name of variable containing output data in estimation_model.</dd>
<dt><strong><code>sigma</code></strong> :&ensp;<code>float</code></dt>
<dd>Elasticity of substitution.</dd>
<dt><strong><code>results_key</code></strong> :&ensp;<code>str</code></dt>
<dd>(optional) If using parameter estimates from estimation_model, this is the key (i.e.
sector) corresponding to the estimates to be used. For single sector estimations (sector_by_sector =
False in GME model), this key is 'all', which is the default.</dd>
<dt><strong><code>cost_variables</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>(optional) A list of variables to use to compute bilateral trade costs. By
default, all included non-fixed effect variables are used.</dd>
<dt><strong><code>parameter_values</code></strong> :&ensp;<code><a title="models.OneSectorGE.ParameterValues" href="#models.OneSectorGE.ParameterValues">ParameterValues</a></code></dt>
<dd>(optional) A set of parameter values or estimates to use for constructing
trade costs. Should be of type gegravity.ParameterValues, statsmodels.GLMResultsWrapper, or
gme.SlimResults. If no values are provided, the estimates in the EstimationModel are used.</dd>
<dt><strong><code>quiet</code></strong> :&ensp;<code>bool</code></dt>
<dd>(optional) If True, suppresses all console feedback from model during simulation. Default is False.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>aggregate_trade_results</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Country-level, aggregate results. See models.ResultsLabels for
column details.</dd>
<dt><strong><code>baseline_trade_costs</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The constructed baseline trade costs for each bilateral pair
(t_{ij}^{1-sigma}). Calculated as exp{sum_k (B^k*x^k_ij)} for all cost variables x^k and estimate
values B.</dd>
<dt><strong><code>bilateral_trade_results</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Bilateral trade results. See models.ResultsLabels for
column details.</dd>
<dt><strong><code>country_mr_terms</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Baseline and counterfactual inward and outward multilateral resistance
estimates. See models.ResultsLabels for column details.</dd>
<dt><strong><code>country_results</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>A collection of the main country-level simulation results. See
models.ResultsLabels for column details.</dd>
<dt><strong><code>country_set</code></strong> :&ensp;<code>dict[<a title="models.OneSectorGE.Country" href="#models.OneSectorGE.Country">Country</a>]</code></dt>
<dd>A dictionary containing a Country object for each country in the model, keyed
by their respective identifiers.</dd>
<dt><strong><code>cost_shock</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The baseline and experiment trade costs combined.</dd>
<dt><strong><code>economy</code></strong> :&ensp;<code><a title="models.OneSectorGE.Economy" href="#models.OneSectorGE.Economy">Economy</a></code></dt>
<dd>The model's Economy object.</dd>
<dt><strong><code>experiment_data</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The counterfactual experiment data.</dd>
<dt><strong><code>experiment_trade_costs</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The constructed experiment trade costs for each bilateral pair
(t_{ij}^{1-sigma}). Calculated as exp{sum_k (B^k*x^k_ij)} for all cost variables x^k and estimate
values B</dd>
<dt><strong><code>factory_gate_prices</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Counterfactual prices (baseline prices are all normalized to 1).</dd>
<dt><strong><code>outputs_expenditures</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Baseline and counterfactual expenditure and output values. See
models.ResultsLabels for column details.</dd>
<dt><strong><code>sigma</code></strong> :&ensp;<code>int</code></dt>
<dd>The elasticity of substitution parameter value</dd>
<dt><strong><code>solver_diagnostics</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of solver diagnostics for the three solution routines: baseline
multilateral resistances, conditional multilateral resistances (partial equilibrium counterfactual
effects) and the full GE model. Each element contains a dictionary of various diagnostic info from
scipy.optimize.root.</dd>
</dl>
<p>Examples:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OneSectorGE(object):
    def __init__(self,
                 estimation_model: EstimationModel,
                 year: str,
                 reference_importer: str,
                 expend_var_name: str = &#39;expenditure&#39;,
                 output_var_name: str = &#39;output&#39;,
                 sigma: float = 5,
                 results_key: str = &#39;all&#39;,
                 cost_variables: List[str] = None,
                 parameter_values = None,
                 #approach: str = None,
                 quiet:bool = False):
        &#39;&#39;&#39;
        Define a general equilibrium (GE) gravity model.
        Args:
            estimation_model (gme.EstimationModel): A GME Estimation model
            year (str): The year to be used for the model. Works best if estimation_model year column has been cast as
                string too.
            reference_importer (str): Identifier for the country to be used as the reference importer (inward
                multilateral resistance normalized to 1 and other multilateral resistances solved relative to it).
            expend_var_name (str): Column name of variable containing expenditure data in estimation_model.
            output_var_name (str): Column name of variable containing output data in estimation_model.
            sigma (float): Elasticity of substitution.
            results_key (str): (optional) If using parameter estimates from estimation_model, this is the key (i.e.
                sector) corresponding to the estimates to be used. For single sector estimations (sector_by_sector =
                False in GME model), this key is &#39;all&#39;, which is the default.
            cost_variables (List[str]): (optional) A list of variables to use to compute bilateral trade costs. By
                default, all included non-fixed effect variables are used.
            parameter_values (ParameterValues): (optional) A set of parameter values or estimates to use for constructing
                trade costs. Should be of type gegravity.ParameterValues, statsmodels.GLMResultsWrapper, or
                gme.SlimResults. If no values are provided, the estimates in the EstimationModel are used.
            quiet (bool): (optional) If True, suppresses all console feedback from model during simulation. Default is False.

        Attributes:
            aggregate_trade_results (pandas.DataFrame): Country-level, aggregate results. See models.ResultsLabels for
                column details.
            baseline_trade_costs (pandas.DataFrame): The constructed baseline trade costs for each bilateral pair
                (t_{ij}^{1-sigma}). Calculated as exp{sum_k (B^k*x^k_ij)} for all cost variables x^k and estimate
                values B.
            bilateral_trade_results (pandas.DataFrame): Bilateral trade results. See models.ResultsLabels for
                column details.
            country_mr_terms (pandas.DataFrame): Baseline and counterfactual inward and outward multilateral resistance
                estimates. See models.ResultsLabels for column details.
            country_results (pandas.DataFrame): A collection of the main country-level simulation results. See
                models.ResultsLabels for column details.
            country_set (dict[Country]): A dictionary containing a Country object for each country in the model, keyed
                by their respective identifiers.
            cost_shock (pandas.DataFrame): The baseline and experiment trade costs combined.
            economy (Economy): The model&#39;s Economy object.
            experiment_data (pandas.DataFrame): The counterfactual experiment data.
            experiment_trade_costs (pandas.DataFrame): The constructed experiment trade costs for each bilateral pair
                (t_{ij}^{1-sigma}). Calculated as exp{sum_k (B^k*x^k_ij)} for all cost variables x^k and estimate
                values B
            factory_gate_prices (pandas.DataFrame): Counterfactual prices (baseline prices are all normalized to 1).
            outputs_expenditures (pandas.DataFrame): Baseline and counterfactual expenditure and output values. See
                models.ResultsLabels for column details.
            sigma (int): The elasticity of substitution parameter value
            solver_diagnostics (dict): A dictionary of solver diagnostics for the three solution routines: baseline
                multilateral resistances, conditional multilateral resistances (partial equilibrium counterfactual
                effects) and the full GE model. Each element contains a dictionary of various diagnostic info from
                scipy.optimize.root.

        Examples:

        &#39;&#39;&#39;
        # &#39;&#39;&#39;
        #
        # # ---
        # # Methods
        # # ---
        #
        # ##
        # # Model Construction and Simulation
        # ##
        #
        # build_baseline(omr_rescale: float = 1, imr_rescale: float = 1,  mr_method: str = &#39;hybr&#39;,
        #                mr_max_iter: int = 1400, mr_tolerance: float = 1e-8)
        #     Solve the baseline model. This primarily solves for the baseline Multilateral Resistance (MR) terms.
        #
        # define_experiment(experiment_data: DataFrame = None)
        #     Specify the counterfactual data to use for experiment.
        #
        # simulate(ge_method: str = &#39;hybr&#39;, ge_tolerance: float = 1e-8, ge_max_iter: int = 1000)
        #     Simulate the counterfactual scenario.
        #
        # ##
        # # Post-simulation Analysis
        # ##
        #
        # trade_share(importers: List[str], exporters: List[str])
        #     Calculate baseline and experiment import and export shares (in percentages) between user-supplied countries.
        #
        # export_results(directory:str = None, name:str = &#39;&#39;)
        #     Export results to csv files. Three files are stored containing (1) country-level results, (2) bilateral
        #     results, and (3) solver diagnostics.
        #
        # calculate_levels(how: str = &#39;country&#39;):
        #     Calculate changes in the level (value) of trade using baseline trade values and simulation outcomes. Results
        #     can be calculated at either the country level or bilateral level.
        #
        # ##
        # # Trouble-shooting
        # ##
        #
        # test_baseline_mr_function(inputs_only:bool=False)
        #     Test whether the multilateral resistance system of equations can be computed from baseline data. Helpful for
        #     debugging initial data problems. Note that the returned function values reflect those generated by the
        #     initial values and do not reflect a solution to the system.
        #
        # check_omr_rescale(omr_rescale_range:int = 10, mr_method: str = &#39;hybr&#39;, mr_max_iter: int = 1400,
        #                  mr_tolerance: float = 1e-8, countries:List[str] = [])
        #     Analyze different Outward Multilarteral Resistance (OMR) term rescale factors. This method can help identify
        #     feasible values to use for the omr_rescale argument in OneSectorGE.build_baseline().
        # &#39;&#39;&#39;
        if not isinstance(year, str):
            raise TypeError(&#39;year should be a string&#39;)

        # Check reference country (does not currently work)
        # try:
        #     omitted_fe = estimation_model.results_dict[results_key].params[(&#39;importer_fe_&#39;+reference_importer)]
        #     raise ValueError(&#39;reference_importer should be the excluded importer fixed effect&#39;)
        # except:
        #     print(&#39;reference_importer OK&#39;)
        self.labels = ResultsLabels()
        self.meta_data = _GEMetaData(estimation_model.estimation_data._meta_data, expend_var_name, output_var_name)
        self._estimation_model = estimation_model
        if parameter_values is None:
            self._estimation_results = self._estimation_model.results_dict[results_key]
        else:
            self._estimation_results = None
        self._year = str(year)
        self.sigma = sigma
        self._reference_importer = reference_importer
        self._omr_rescale = None
        self._imr_rescale = None
        self._mr_max_iter = None
        self._mr_tolerance = None
        self._mr_method = None
        self._ge_method = None
        self._ge_tolerance = None
        self._ge_max_iter = None
        self.country_set = None
        self.economy = None
        self.baseline_trade_costs = None # t_{ij}^{1-sigma}
        self.experiment_trade_costs = None # t_{ij}^{1-sigma}
        self.cost_shock = None
        self.experiment_data = None
        self.approach = None # Disabled until GEPPML is completed
        self.quiet = quiet

        # Results fields
        self.bilateral_trade_results = None
        self.aggregate_trade_results = None
        self.solver_diagnostics = dict()
        self.factory_gate_prices = None
        self.outputs_expenditures = None
        self.country_results = None
        self.country_mr_terms = None

        # Status checks
        self._baseline_built = False
        self._experiment_defined = False


        # ---
        # Check inputs
        # ---
        if self.meta_data.trade_var_name is None:
            raise ValueError(&#39;\n Missing Input: Please insure trade_var_name is set in EstimationData object.&#39;)

        if cost_variables is None:
            self.cost_variables = self._estimation_model.specification.rhs_var
        else:
            self.cost_variables = cost_variables

        if parameter_values is not None:
            self.cost_coeffs = parameter_values.params
        else:
            self.cost_coeffs = self._estimation_results.params[self.cost_variables]


        # prep baseline data
        _baseline_data = estimation_model.estimation_data.data_frame.copy()
        _baseline_data[self.meta_data.year_var_name] = _baseline_data[self.meta_data.year_var_name].astype(str)
        self.baseline_data = _baseline_data.loc[_baseline_data[self.meta_data.year_var_name] == self._year, :].copy()
        if self.baseline_data.shape[0] == 0:
            raise ValueError(&#34;There are no observations corresponding to the supplied &#39;year&#39;&#34;)


        # Initialize a set of countries and the economy
        self.country_set = self._create_baseline_countries()
        self.economy = self._create_baseline_economy()
        # Calculate certain country values using info from the whole economy
        for country in self.country_set:
            self.country_set[country]._calculate_baseline_output_expenditure_shares(self.economy)
        # Calculate baseline trade costs
        self.baseline_trade_costs = self._create_trade_costs(self.baseline_data)




    def build_baseline(self,
                       omr_rescale: float = 1,
                       imr_rescale: float = 1,
                       mr_method: str = &#39;hybr&#39;,
                       mr_max_iter: int = 1400,
                       mr_tolerance: float = 1e-8):
        &#39;&#39;&#39;
        Solve the baseline model. This primarily solves for the baseline Multilateral Resistance (MR) terms.
        Args:
            omr_rescale (int): (optional) This value rescales the OMR values to assist in convergence. Often, OMR values
                are orders of magnitude different than IMR values, which can make convergence difficult. Scaling by a
                different order of magnitude can help. Values should be of the form 10^n. By default, this value is 1
                (10^0). However, users should be careful with this choice as results, even when convergent, may not be
                fully robust to any selection. The method OneSectorGE.check_omr_rescale() can help identify and compare
                feasible values.
            imr_rescale (int): (optional) This value rescales the IMR values to potentially aid in conversion. However,
                because the IMR for the reference importer is normalized to one, it is unlikely that there will be because
                because changing the default value, which is 1.
            mr_method (str): This parameter determines the type of non-linear solver used for solving the baseline and
                experiment MR terms. See the documentation for scipy.optimize.root for alternative methods. the default
                value is &#39;hybr&#39;.
            mr_max_iter (int): (optional) This parameter sets the maximum limit on the number of iterations conducted
                by the solver used to solve for MR terms. The default value is 1400.
            mr_tolerance (float): (optional) This parameterset the convergence tolerance level for the solver used to
                solve for MR terms. The default value is 1e-8.

        Returns:
            None: Populates Attributes of model object.
        &#39;&#39;&#39;
        self._omr_rescale = omr_rescale
        self._imr_rescale = imr_rescale
        self._mr_max_iter = mr_max_iter
        self._mr_tolerance = mr_tolerance
        self._mr_method = mr_method

        # Solve for the baseline multilateral resistance terms
        if self.approach == &#39;GEPPML&#39;:
            if self._estimation_results is None:
                raise ValueError(&#34;GEPPML approach requires that the gme.EstimationModel be estimated and use importer and exporter fixed effects.&#34;)
            self._calculate_GEPPML_multilateral_resistance(version=&#39;baseline&#39;)
        else:
            self._calculate_multilateral_resistance(trade_costs=self.baseline_trade_costs, version=&#39;baseline&#39;)
        # Calculate baseline factory gate prices
        self._calculate_baseline_factory_gate_params()
        self._baseline_built = True

        # ToDo: run some checks the ensure the baseline is solved (e.g. the betas solve the factory gat price equations)

    def _create_baseline_countries(self):
        &#34;&#34;&#34;
        Initialize set of country objects
        &#34;&#34;&#34;
        # Requires that the baseline data has output and expenditure data

        # Make sure the year data is in string form
        self.baseline_data[self.meta_data.year_var_name] = self.baseline_data.loc[:,
                                                           self.meta_data.year_var_name].astype(str)

        # Create Country-level observations
        year_data = self.baseline_data.loc[self.baseline_data[self.meta_data.year_var_name] == self._year, :]

        importer_info = year_data[[self.meta_data.imp_var_name, self.meta_data.expend_var_name]].copy()

        importer_info = importer_info.groupby([self.meta_data.imp_var_name])
        expenditures = importer_info.mean().reset_index()

        exporter_info = year_data[[self.meta_data.exp_var_name, self.meta_data.output_var_name]].copy()
        exporter_info = exporter_info.groupby([self.meta_data.exp_var_name])
        output = exporter_info.mean().reset_index()

        country_data = pd.merge(left=expenditures,
                                right=output,
                                how=&#39;outer&#39;,
                                left_on=[self.meta_data.imp_var_name],
                                right_on=[self.meta_data.exp_var_name])

        reference_expenditure = float(
            country_data.loc[country_data[self.meta_data.imp_var_name] == self._reference_importer,
                             self.meta_data.expend_var_name])

        # Convert DataFrame to a dictionary of country objects
        country_set = {}

        # Identify appropriate fixed effect naming convention and define function for creating them
        fe_specification = self._estimation_model.specification.fixed_effects
        # Importer FEs
        if [self.meta_data.imp_var_name] in fe_specification:
            def imp_fe_identifier(country_id):
                return &#34;_&#34;.join([self.meta_data.imp_var_name,
                                 &#39;fe&#39;, (country_id)])
        elif [self.meta_data.imp_var_name, self.meta_data.year_var_name] in fe_specification:
            def imp_fe_identifier(country_id):
                return &#34;_&#34;.join([self.meta_data.imp_var_name, self.meta_data.year_var_name,
                                 &#39;fe&#39;, (country_id + self._year)])
        else:
            raise ValueError(&#34;Fixed Effect Specification must feature {} or {}&#34;.format([self.meta_data.imp_var_name],
                                                                                       [self.meta_data.imp_var_name,
                                                                                        self.meta_data.year_var_name]))

        # Exporter FEs
        if [self.meta_data.exp_var_name] in fe_specification:
            def exp_fe_identifier(country_id):
                return &#34;_&#34;.join([self.meta_data.exp_var_name,
                                 &#39;fe&#39;, (country_id)])
        elif [self.meta_data.imp_var_name, self.meta_data.year_var_name] in fe_specification:
            def exp_fe_identifier(country_id):
                return &#34;_&#34;.join([self.meta_data.exp_var_name, self.meta_data.year_var_name,
                                 &#39;fe&#39;, (country_id + self._year)])
        else:
            raise ValueError(
                &#34;Fixed Effect Specification must feature {} or {}&#34;.format([self.meta_data.exp_var_name],
                                                                          [self.meta_data.exp_var_name,
                                                                           self.meta_data.year_var_name]))

        for row in range(country_data.shape[0]):
            country_id = country_data.loc[row, self.meta_data.imp_var_name]

            # Get fixed effects if estimated
            try:
                bsln_imp_fe = self._estimation_results.params[imp_fe_identifier(country_id)]
            except:
                bsln_imp_fe = &#39;no estimate&#39;
            try:
                bsln_exp_fe = self._estimation_results.params[exp_fe_identifier(country_id)]
            except:
                bsln_exp_fe = &#39;no estimate&#39;

            # Build country
            try:
                country_ob = Country(identifier=country_id,
                                     year=self._year,
                                     baseline_output=country_data.loc[row, self.meta_data.output_var_name],
                                     baseline_expenditure=country_data.loc[row, self.meta_data.expend_var_name],
                                     baseline_importer_fe=bsln_imp_fe,
                                     baseline_exporter_fe=bsln_exp_fe,
                                     reference_expenditure=reference_expenditure)
            except:
                raise ValueError(
                    &#34;Missing baseline information for {}. Check that there are output and expenditure data.&#34;.format(
                        country_id))

            country_set[country_ob.identifier] = country_ob

        return country_set

    def _create_baseline_economy(self):
        # Initialize Economy
        economy = Economy(sigma=self.sigma)
        economy._initialize_baseline_total_output_expend(self.country_set)
        return economy

    def _create_trade_costs(self,
                            data_set: object = None):
        &#39;&#39;&#39;
        Create bilateral trade costs. Returned values reflect \hat{t}^{1-\sigma}_{ij}, not \hat{t}. See equation (32)
        from Larch and Yotov (2016) &#34;GENERAL EQUILIBRIUM TRADE POLICY ANALYSIS WITH STRUCTURAL GRAVITY&#34;
        :param data_set: (DataFrame) The trade cost data to base trade costs on (either baseline or experimental)
        :return: (DataFrame) DataFrame of bilateral trade costs (t^{1-sigma})
        &#39;&#39;&#39;
        obs_id = [self.meta_data.imp_var_name,
                  self.meta_data.exp_var_name,
                  self.meta_data.year_var_name]
        weighted_costs = data_set[obs_id + self.cost_variables].copy()
        weighted_list = []
        # Cumulatively add each variable in the list of cost variables.
        for variable in self.cost_variables:
            weighted_costs[(&#39;cost_weighted_&#39; + variable)] = self.cost_coeffs[variable] * \
                                                            weighted_costs[[variable]]
            weighted_list = weighted_list + [(&#39;cost_weighted_&#39; + variable)]
        # Generate cost measure t^{1-sigma}
        weighted_costs[&#39;trade_cost&#39;] = np.exp(weighted_costs[weighted_list].sum(axis=1))
        # Run some checks for completeness
        if weighted_costs.isna().any().any():
            warn(&#34;\n Calculated trade costs contain missing (nan) values. Check parameter values and trade cost variables in baseline or experiment data.&#34;)
        if weighted_costs.shape[0] != len(self.country_set.keys())**2:
            warn(&#34;\n Calculated trade costs are not square. Some bilateral costs are absent.&#34;)
        return weighted_costs[obs_id + [&#39;trade_cost&#39;]]

    def _create_cost_output_expend_params(self, trade_costs):
        # Prepare cost/expenditure and cost/output parameters
        # cost_output_share: t_{ij}^{1-\sigma} * Y_i / Y
        # cost_expend_share: t_{ij}^{1-\sigma} * E_j / Y
        cost_params = trade_costs.copy()
        cost_params[&#39;cost_output_share&#39;] = -9999
        cost_params[&#39;cost_expend_share&#39;] = -9999
        # Build actual values
        for row in cost_params.index:
            importer_key = cost_params.loc[row, self.meta_data.imp_var_name]
            exporter_key = cost_params.loc[row, self.meta_data.exp_var_name]
            cost_params.loc[row, &#39;cost_output_share&#39;] = cost_params.loc[row, &#39;trade_cost&#39;] \
                                                        * self.country_set[exporter_key].baseline_output_share
            cost_params.loc[row, &#39;cost_expend_share&#39;] = cost_params.loc[row, &#39;trade_cost&#39;] \
                                                        * self.country_set[importer_key].baseline_expenditure_share
        cost_params.sort_values([self.meta_data.exp_var_name, self.meta_data.imp_var_name], inplace=True)
        # Reshape to a Matrix with exporters as rows, importers as columns
        cost_exp_shr = cost_params.pivot(index=self.meta_data.exp_var_name,
                                         columns=self.meta_data.imp_var_name,
                                         values=&#39;cost_expend_share&#39;)
        cost_out_shr = cost_params.pivot(index=self.meta_data.exp_var_name,
                                         columns=self.meta_data.imp_var_name,
                                         values=&#39;cost_output_share&#39;)
        if np.isnan(cost_exp_shr.values).any():
            warn(&#34;\n &#39;cost_exp_share&#39; values contain missing (nan) values. \n 1. Check that expenditure shares exist for all countries in country_set \n 2. Check that trade cost data is square and no bilateral pairs are missing.&#34;)
        if np.isnan(cost_out_shr.values).any():
            warn(&#34;\n &#39;cost_out_share&#39; values contain missing (nan) values. \n 1. Check that output shares exist for all countries in country_set \n 2. Check that trade cost data is square no bilateral pairs are missing.&#34;)

        # Convert to numpy array to improve solver speed
        built_params = dict()
        built_params[&#39;cost_exp_shr&#39;] = cost_exp_shr.values
        built_params[&#39;cost_out_shr&#39;] = cost_out_shr.values


        return built_params

    def _calculate_multilateral_resistance(self,
                                           trade_costs: DataFrame,
                                           version: str,
                                           test=False,
                                           inputs_only=False):
        # Step 1: Build parameters for solver
        mr_params = dict()
        country_list = list(self.country_set.keys())
        mr_params[&#39;number_of_countries&#39;] = len(country_list)
        mr_params[&#39;omr_rescale&#39;] = self._omr_rescale
        mr_params[&#39;imr_rescale&#39;] = self._imr_rescale
        # Calculate parameters reflecting trade costs, output shares, and expenditure shares
        cost_shr_params = self._create_cost_output_expend_params(trade_costs=trade_costs)
        # cost_output_share: t_{ij}^{1-\sigma} * Y_i / Y
        # cost_expend_share: t_{ij}^{1-\sigma} * E_j / Y
        mr_params[&#39;cost_exp_shr&#39;] = cost_shr_params[&#39;cost_exp_shr&#39;]
        mr_params[&#39;cost_out_shr&#39;] = cost_shr_params[&#39;cost_out_shr&#39;]

        # Step 2: Solve
        initial_values = [1] * (2 * mr_params[&#39;number_of_countries&#39;] - 1)
        if test:
            # Option for testing and diagnosing the MR function
            test_diagnostics = dict()
            test_diagnostics[&#39;initial values&#39;] = initial_values
            test_diagnostics[&#39;mr_params&#39;] = mr_params
            if inputs_only:
                return test_diagnostics
            else:
                test_diagnostics[&#39;function_value&#39;] = &#39;unsolved&#39;
                test_diagnostics[&#39;function_value&#39;] = _multilateral_resistances(initial_values, mr_params)
                return test_diagnostics
        # Actual Solver
        else:
            if not self.quiet:
                print(&#39;Solving for {} MRs...&#39;.format(version))
            solved_mrs = root(_multilateral_resistances, initial_values, args=mr_params, method=self._mr_method,
                              tol=self._mr_tolerance,
                              options={&#39;xtol&#39;: self._mr_tolerance, &#39;maxfev&#39;: self._mr_max_iter})
            if solved_mrs.message == &#39;The solution converged.&#39;:
                if not self.quiet:
                    print(solved_mrs.message)
            else:
                warn(solved_mrs.message)
            self.solver_diagnostics[version + &#34;_MRs&#34;] = solved_mrs

            # Step 3: Pack up results
            country_list.sort()
            imrs = solved_mrs.x[0:len(country_list) - 1] * mr_params[&#39;imr_rescale&#39;]
            imrs = np.append(imrs, 1)
            omrs = solved_mrs.x[len(country_list) - 1:] * mr_params[&#39;omr_rescale&#39;]
            mrs = pd.DataFrame(data={&#39;imrs&#39;: imrs, &#39;omrs&#39;: omrs}, index=country_list)

            if version == &#39;baseline&#39;:
                for country in country_list:
                    self.country_set[country]._baseline_imr_ratio = mrs.loc[country, &#39;imrs&#39;]  # 1 / P^{1-sigma}
                    self.country_set[country]._baseline_omr_ratio = mrs.loc[country, &#39;omrs&#39;]  # 1 / π^{1-sigma}

            if version == &#39;conditional&#39;:
                for country in country_list:
                    self.country_set[country]._conditional_imr_ratio = mrs.loc[country, &#39;imrs&#39;]  # 1 / P^{1-sigma}
                    self.country_set[country]._conditional_omr_ratio = mrs.loc[country, &#39;omrs&#39;]  # 1 / π^{1-sigma}

    def _calculate_GEPPML_multilateral_resistance(self, version):
        &#39;&#39;&#39;
        Construct fixed effects according to Yotov, Piermartini, Monteiro, and Larch (2016),
        &#34;An Advanced Guide to Trade Policy Analysis: The Structural Gravity Model (Online Revised Version)
        Follows GEPPML approach and MRLs are based on equations (2-38) and (2-39)
        &#39;&#39;&#39;
        country_list = list(self.country_set.keys())

        # ToDo: Try recalculating the output expenditure measures

        def _GEPPML_OMR(Y_i, E_R, exp_fe_i):
            &#39;&#39;&#39;
            Calculate outward multilateral resistance based on equation (2-38): π_i^(1-sigma)
                Y_i: Output for exporter i
                E_r: Expenditure for the reference country
                exp_fe_i: Estimated exporter fixed effect for country i
            &#39;&#39;&#39;
            return (Y_i * E_R) / math.exp(exp_fe_i)

        def _GEPPML_IMR(E_j, E_R, imp_fe_j):
            &#39;&#39;&#39;
            Calculate inward multilateral resistance based on equation (2-39): P_j^(1-sigma)
                E_j: Expenditure for importer j
                E_R: Expenditure for the reference country
                imp_fe_j: Estimated importer fixed effect for country j
            &#39;&#39;&#39;
            return E_j / (math.exp(imp_fe_j) * E_R)

        if version == &#39;baseline&#39;:
            reference_expnd = self.country_set[self._reference_importer].baseline_expenditure
            for country in country_list:
                country_obj = self.country_set[country]

                # Set values for reference importer
                if country == self._reference_importer:

                    # Check that the estimation produced appropriate fixed effect estimates
                    if country_obj.baseline_importer_fe != &#39;no estimate&#39;:
                        warn(&#34;There exists an importer fixed effect estimate for the reference country.&#34;
                             &#34; Check that the fixed effect specification correctly omits the reference country&#34;)
                    if country_obj.baseline_exporter_fe == &#39;no estimate&#39;:
                        raise ValueError(&#34;No exporter fixed effect estimate for {}&#34;.format(country))
                    # P_R = 1 by construction
                    imr = 1
                    # π_i^(1-sigma)
                    omr = _GEPPML_OMR(Y_i=country_obj.baseline_output, E_R=reference_expnd,
                                      exp_fe_i=country_obj.baseline_exporter_fe)
                    self.country_set[country]._baseline_imr_ratio = 1 / imr  # 1 / P^{1-sigma}
                    self.country_set[country]._baseline_omr_ratio = 1 / omr  # 1 / π^{1-sigma}

                # Set values for every other country
                else:
                    # Check that there exist fixed effect estimates
                    if country_obj.baseline_importer_fe == &#39;no estimate&#39;:
                        raise ValueError(&#34;No importer fixed effect estimate for {}&#34;.format(country))
                    if country_obj.baseline_exporter_fe == &#39;no estimate&#39;:
                        raise ValueError(&#34;No exporter fixed effect estimate for {}&#34;.format(country))
                    # π_i^(1-sigma)
                    omr = _GEPPML_OMR(Y_i=country_obj.baseline_output, E_R=reference_expnd,
                                      exp_fe_i=country_obj.baseline_exporter_fe)
                    # P_j^(1-sigma)
                    imr = _GEPPML_IMR(E_j=country_obj.baseline_expenditure, E_R=reference_expnd,
                                      imp_fe_j=country_obj.baseline_exporter_fe)

                    self.country_set[country]._baseline_imr_ratio = 1 / imr  # 1 / P^{1-sigma}
                    self.country_set[country]._baseline_omr_ratio = 1 / omr  # 1 / π^{1-sigma}

        if version == &#39;conditional&#39;:
            # Step 1: Re-estimate model
            baseline_specification = self._estimation_model.specification
            counter_factual_data = self.experiment_data.copy()
            counter_factual_data = counter_factual_data.merge(self.experiment_trade_costs, how=&#39;inner&#39;,
                                                              on=[self.meta_data.exp_var_name,
                                                                  self.meta_data.imp_var_name,
                                                                  self.meta_data.year_var_name])
            counter_factual_data[&#39;adjusted_trade&#39;] = counter_factual_data[baseline_specification.lhs_var] / \
                                                     counter_factual_data[&#39;trade_cost&#39;]
            # ToDo: Perform estimation - May not work with GME.estimate() due to lack of rhs vars. If so, need to figure out how to deal with dropped FE in estimation stage.

            # ToDo: Step 2: Calculate shit.


    def _calculate_baseline_factory_gate_params(self):
        for country in self.country_set.keys():
            self.country_set[country].factory_gate_price_param = self.country_set[country].baseline_output_share \
                                                                 * self.country_set[country]._baseline_omr_ratio

    def define_experiment(self, experiment_data: DataFrame):
        &#39;&#39;&#39;
        Specify the counterfactual data to use for experiment.
        Args:
            experiment_data(Pandas.DataFrame): A dataframe contianing the counterfactual trade-cost data to use for the
                experiment. The best approach for creating this data is to copy the baseline data
                (OneSectorGE.baseline_data.copy()) and modify columns/rows to reflect desired counterfactual experiment.

        Returns:
            None:
                There is no return but the new information is added to model.
        &#39;&#39;&#39;
        if not self._baseline_built:
            raise ValueError(&#34;Baseline must be built first (i.e. ge_model.build_baseline() method&#34;)
        self.experiment_data = experiment_data
        self.experiment_trade_costs = self._create_trade_costs(self.experiment_data)
        cost_change = self.baseline_trade_costs.merge(right=self.experiment_trade_costs, how=&#39;outer&#39;,
                                                      on=[self.meta_data.imp_var_name,
                                                          self.meta_data.exp_var_name,
                                                          self.meta_data.year_var_name])
        cost_change.rename(columns={&#39;trade_cost_x&#39;: &#39;baseline_trade_cost&#39;, &#39;trade_cost_y&#39;: &#39;experiment_trade_cost&#39;},
                           inplace=True)
        self.cost_shock = cost_change.loc[cost_change[&#39;baseline_trade_cost&#39;] != cost_change[&#39;experiment_trade_cost&#39;]]
        self._experiment_defined = True

    def simulate(self, ge_method: str = &#39;hybr&#39;, ge_tolerance: float = 1e-8, ge_max_iter: int = 1000):
        &#39;&#39;&#39;
        Simulate the counterfactual scenario
        Args:
            ge_method (str): (optional) The solver method to use for the full GE non-linear solver. See scipy.root()
                documentation for option. Default is &#39;hybr&#39;.
            ge_tolerance (float): (optional) The tolerance for determining if the GE system of equations is solved.
                Default is 1e-8.
            ge_max_iter (int): (optional) The maximum number of iterations allowed for the full GE nonlinear solver.
                Default is 1000.

        Returns:
            None
                No return but populates new attributes of model.
        &#39;&#39;&#39;
        # &#39;&#39;&#39;
        # Simulate the counterfactual scenario.
        # :param ge_method: (str)
        # :param ge_tolerance: (float)
        #
        # :param ge_max_iter: (int)
        # :return: (None) No return but many fields in the model containing results are populated.
        # &#39;&#39;&#39;
        if not self._baseline_built:
            raise ValueError(&#34;Baseline must be built first (i.e. OneSectorGE.build_baseline() method&#34;)
        if not self._experiment_defined:
            raise ValueError(&#34;Expiriment must be defined first (i.e. OneSectorGE.define_expiriment() method&#34;)
        self._ge_method = ge_method
        self._ge_tolerance = ge_tolerance
        self._ge_max_iter = ge_max_iter
        # Step 1: Simulate conditional GE
        if self.approach == &#39;GEPPML&#39;:
            self._calculate_GEPPML_multilateral_resistance(version=&#39;conditional&#39;)
        else:
            self._calculate_multilateral_resistance(trade_costs=self.experiment_trade_costs, version=&#39;conditional&#39;)
        # Step 2: Simulate full GE
        self._calculate_full_ge()
        # Step 3: Generate post-simulation results
        [self.country_set[country]._construct_country_measures(sigma=self.sigma) for country in self.country_set.keys()]
        self._construct_experiment_output_expend()
        self._construct_experiment_trade()
        self._compile_results()

    def _calculate_full_ge(self):
        # Solve Full GE model
        ge_params = dict()
        country_list = list(self.country_set.keys())
        country_list.sort()
        ge_params[&#39;number_of_countries&#39;] = len(country_list)
        ge_params[&#39;omr_rescale&#39;] = self._omr_rescale
        ge_params[&#39;imr_rescale&#39;] = self._imr_rescale
        ge_params[&#39;sigma&#39;] = self.sigma
        # Calculate parameters reflecting trade costs, output shares, and expenditure shares
        cost_shr_params = self._create_cost_output_expend_params(trade_costs=self.experiment_trade_costs)
        ge_params[&#39;cost_exp_shr&#39;] = cost_shr_params[&#39;cost_exp_shr&#39;]
        ge_params[&#39;cost_out_shr&#39;] = cost_shr_params[&#39;cost_out_shr&#39;]

        init_imr = list()
        init_omr = list()
        output_share = list()
        factory_gate_params = list()
        for country in country_list:
            init_imr.append(self.country_set[country]._conditional_imr_ratio)
            init_omr.append(self.country_set[country]._conditional_omr_ratio)
            output_share.append(self.country_set[country].baseline_output_share)
            factory_gate_params.append(self.country_set[country].factory_gate_price_param)

        init_imr = [mr / ge_params[&#39;imr_rescale&#39;] for mr in init_imr]
        init_omr = [mr / ge_params[&#39;omr_rescale&#39;] for mr in init_omr]

        ge_params[&#39;output_shr&#39;] = output_share
        ge_params[&#39;factory_gate_param&#39;] = factory_gate_params

        init_price = [1] * len(country_list)
        initial_values = init_imr[0:len(country_list) - 1] + init_omr + init_price
        initial_values = np.array(initial_values)
        if not self.quiet:
            print(&#39;Solving full GE model...&#39;)
        full_ge_results = root(_full_ge, initial_values, args=ge_params, method=self._ge_method, tol=self._ge_tolerance,
                               options={&#39;xtol&#39;: self._ge_tolerance, &#39;maxfev&#39;: self._ge_max_iter})
        if full_ge_results.message == &#39;The solution converged.&#39;:
            if not self.quiet:
                print(full_ge_results.message)
        else:
            warn(full_ge_results.message)
        self.solver_diagnostics[&#39;full_GE&#39;] = full_ge_results

        imrs = full_ge_results.x[0:len(country_list) - 1] * ge_params[&#39;imr_rescale&#39;]
        imrs = np.append(imrs, 1)
        omrs = full_ge_results.x[len(country_list) - 1:2 * len(country_list) - 1] * ge_params[&#39;omr_rescale&#39;]
        prices = full_ge_results.x[2 * len(country_list) - 1:]
        factory_gate_prices = pd.DataFrame({&#39;exporter&#39;: country_list,
                                            self.labels.experiment_factory_price: prices})
        self.factory_gate_prices = factory_gate_prices.set_index(&#39;exporter&#39;)
        for i, country in enumerate(country_list):
            self.country_set[country]._experiment_imr_ratio = imrs[i] # 1 / P^{1-sigma}
            self.country_set[country]._experiment_omr_ratio = omrs[i] # 1 / π^{1-sigma}
            self.country_set[country].experiment_factory_price = prices[i]
            self.country_set[country].factory_price_change = 100 * (prices[i] - 1)


    def _construct_experiment_output_expend(self):
        total_output = 0

        results_table = pd.DataFrame(columns=[self.labels.identifier,
                                              self.labels.baseline_output,
                                              self.labels.experiment_output,
                                              self.labels.output_change,
                                              self.labels.baseline_expenditure,
                                              self.labels.experiment_expenditure,
                                              self.labels.expenditure_change])
        # The first time looping through gets calculates total output
        for country in self.country_set.keys():
            country_obj = self.country_set[country]
            total_output += country_obj.experiment_output

        # The second time looping through gets things that are dependent on total output/expenditure
        for country in self.country_set.keys():
            country_obj = self.country_set[country]
            country_obj.experiment_output_share = country_obj.experiment_output / total_output
            results_table = results_table.append({
                self.labels.identifier: country,
                self.labels.baseline_output: country_obj.baseline_output,
                self.labels.experiment_output: country_obj.experiment_output,
                self.labels.output_change: country_obj.output_change,
                self.labels.baseline_expenditure: country_obj.baseline_expenditure,
                self.labels.experiment_expenditure: country_obj.experiment_expenditure,
                self.labels.expenditure_change: country_obj.expenditure_change},
                                                 ignore_index=True)
        # Store some economy-wide values to economy object
        self.economy.experiment_total_output = total_output
        self.economy.output_change = 100 * (total_output - self.economy.baseline_total_output) \
                                     / self.economy.baseline_total_output

        results_table = results_table.set_index(self.labels.identifier)
        # Ensure all values are numeric
        for col in results_table.columns:
            results_table[col] = results_table[col].astype(float)
        # Save to model
        self.outputs_expenditures = results_table

    def _construct_experiment_trade(self):
        &#39;&#39;&#39;
        Construct simulated bilateral trade values.
        :return: None. It sets the values for self.bilateral_trade_results, self.aggregate_trade_results, and many of
        the trade attributes in the country objects.
        &#39;&#39;&#39;
        importer_col = self.meta_data.imp_var_name
        exporter_col = self.meta_data.exp_var_name
        year_col = self.meta_data.year_var_name
        trade_value_col = self.meta_data.trade_var_name

        countries = self.country_set.keys()
        trade_data = self.baseline_data[[exporter_col, importer_col, year_col, trade_value_col]].copy()
        trade_data = trade_data.loc[trade_data[year_col] == self._year, [exporter_col, importer_col, trade_value_col]]

        trade_data.rename(columns={trade_value_col: &#39;baseline_trade&#39;}, inplace=True)

        # Set Placeholder value
        #trade_data[&#39;gravity&#39;] = -9999

        # Construct Modeled trade for each country-pair
        for row in trade_data.index:
            # Collect importer and exporter IDs
            importer = trade_data.loc[row, importer_col]
            exporter = trade_data.loc[row, exporter_col]

            # Collect and generate Experiment Values
            exp_imr_ratio = self.country_set[importer]._experiment_imr_ratio
            exp_omr_ratio = self.country_set[exporter]._experiment_omr_ratio
            expend = self.country_set[importer].experiment_expenditure
            output_share = self.country_set[exporter].experiment_output_share
            # gravity = E_j  *   Y_i/Y      * 1/P_j^{1-sigma} * 1/π_i^{1-sigma}
            gravity = expend * output_share * exp_imr_ratio * exp_omr_ratio
            trade_data.loc[row, &#39;exper_gravity&#39;] = gravity

            # Collect and generate baseline values
            bsln_imr_ratio = self.country_set[importer]._baseline_imr_ratio
            bsln_omr_ratio = self.country_set[exporter]._baseline_omr_ratio
            bsln_expend = self.country_set[importer].baseline_expenditure
            bsln_output_share = self.country_set[exporter].baseline_output_share
            # &#39;gravity&#39; term = E_j     *   Y_i/Y           * 1/P_j^{1-sigma} * 1/π_i^{1-sigma}
            bsln_gravity = bsln_expend * bsln_output_share * bsln_imr_ratio * bsln_omr_ratio
            trade_data.loc[row, &#39;bsln_gravity&#39;] = bsln_gravity

        trade_data = trade_data.merge(self.baseline_trade_costs, how=&#39;left&#39;, on=[importer_col, exporter_col])
        trade_data.rename(columns={&#39;trade_cost&#39;: &#39;baseline_trade_cost&#39;}, inplace=True)

        # Set column labels from label dictionary
        bsln_modeled_trade_label = self.labels.baseline_modeled_trade
        exper_trade_label = self.labels.experiment_trade
        trade_change_label = self.labels.trade_change

        trade_data[bsln_modeled_trade_label] = trade_data[&#39;baseline_trade_cost&#39;] \
                                                                   * trade_data[&#39;bsln_gravity&#39;]

        trade_data = trade_data.merge(self.experiment_trade_costs, how=&#39;left&#39;, on=[importer_col, exporter_col])

        trade_data[exper_trade_label] = trade_data[&#39;trade_cost&#39;] * trade_data[&#39;exper_gravity&#39;]

        trade_data[trade_change_label] = 100 * (trade_data[exper_trade_label] - trade_data[bsln_modeled_trade_label]) \
                                       / trade_data[bsln_modeled_trade_label]

        bilateral_trade_results = trade_data[[exporter_col, importer_col, bsln_modeled_trade_label,
                                                   exper_trade_label, trade_change_label]]
        self.bilateral_trade_results = bilateral_trade_results.set_index([exporter_col, importer_col])

        ##
        # Calculate total Imports (international and domestic)
        ##
        # set more labels from label dictionary
        bsln_agg_imports_label = self.labels.baseline_imports
        exper_agg_imports_label = self.labels.experiment_imports
        agg_import_change_label = self.labels.imports_change

        agg_imports = bilateral_trade_results.copy()
        agg_imports = agg_imports[[importer_col, bsln_modeled_trade_label, exper_trade_label]]
        agg_imports = agg_imports.groupby([importer_col]).agg(&#39;sum&#39;)
        agg_imports.rename(columns={bsln_modeled_trade_label: bsln_agg_imports_label,
                                    exper_trade_label: exper_agg_imports_label}, inplace=True)
        agg_imports[agg_import_change_label] = 100 \
                                               * (agg_imports[exper_agg_imports_label] - agg_imports[bsln_agg_imports_label]) \
                                               / agg_imports[bsln_agg_imports_label]
        ##
        # Calculate foreign imports
        ##
        # set more labels from label dictionary
        bsln_agg_frgn_imports_label = self.labels. baseline_foreign_imports
        exper_agg_frgn_imports_label = self.labels.experiment_foreign_imports
        agg_frgn_import_change_label = self.labels.foreign_imports_change

        foreign_imports = bilateral_trade_results.copy()
        foreign_imports = foreign_imports.loc[foreign_imports[importer_col]!=foreign_imports[exporter_col],:]
        foreign_imports = foreign_imports[[importer_col, bsln_modeled_trade_label, exper_trade_label]]
        foreign_imports = foreign_imports.groupby([importer_col]).agg(&#39;sum&#39;)
        foreign_imports.rename(columns={bsln_modeled_trade_label: bsln_agg_frgn_imports_label,
                                    exper_trade_label: exper_agg_frgn_imports_label}, inplace=True)
        foreign_imports[agg_frgn_import_change_label] = 100 \
                                               * (foreign_imports[exper_agg_frgn_imports_label] - foreign_imports[bsln_agg_frgn_imports_label]) \
                                               / foreign_imports[bsln_agg_frgn_imports_label]

        ##
        # Calculate total exports (foreign + domestic)
        ##
        # Set labels from label dictionary
        bsln_agg_exports_label = self.labels.baseline_exports
        exper_agg_exports_label = self.labels. experiment_exports
        agg_exports_change_label = self.labels.exports_change

        agg_exports = bilateral_trade_results.copy()
        agg_exports = agg_exports[[exporter_col, bsln_modeled_trade_label, exper_trade_label]]
        agg_exports = agg_exports.groupby([exporter_col]).agg(&#39;sum&#39;)
        agg_exports.rename(columns={bsln_modeled_trade_label: bsln_agg_exports_label,
                                    exper_trade_label: exper_agg_exports_label}, inplace=True)
        agg_exports[agg_exports_change_label] = 100 \
                                               * (agg_exports[exper_agg_exports_label] - agg_exports[bsln_agg_exports_label]) \
                                               / agg_exports[bsln_agg_exports_label]
        ##
        # Calculate foreign exports
        ##
        # Set labels from label dictionary
        bsln_agg_frgn_exports_label = self.labels.baseline_foreign_exports
        exper_agg_frgn_exports_label = self.labels.experiment_foreign_exports
        agg_frgn_exports_change_label = self.labels.foreign_exports_change

        foreign_exports = bilateral_trade_results.copy()
        foreign_exports = foreign_exports.loc[foreign_exports[importer_col] != foreign_exports[exporter_col], :]
        foreign_exports = foreign_exports[[exporter_col, bsln_modeled_trade_label, exper_trade_label]]
        foreign_exports = foreign_exports.groupby([exporter_col]).agg(&#39;sum&#39;)
        foreign_exports.rename(columns={bsln_modeled_trade_label: bsln_agg_frgn_exports_label,
                                        exper_trade_label: exper_agg_frgn_exports_label}, inplace=True)
        foreign_exports[agg_frgn_exports_change_label] = 100 \
                                                           * (foreign_exports[exper_agg_frgn_exports_label] -
                                                              foreign_exports[bsln_agg_frgn_exports_label]) \
                                                           / foreign_exports[bsln_agg_frgn_exports_label]


        agg_trade = pd.concat([agg_exports, foreign_exports, agg_imports, foreign_imports], axis=1).reset_index()
        agg_trade.rename(columns={&#39;index&#39;: self.labels.identifier}, inplace=True)


        # ----
        # Get Intranational Trade
        # ----
        bsln_intra_label = self.labels.baseline_intranational_trade
        exper_intra_label = self.labels.experiment_intranational_trade
        intra_change_label = self.labels.intranational_trade_change
        intranational = bilateral_trade_results.copy()
        intranational = intranational.loc[intranational[importer_col] == intranational[exporter_col], :]
        intranational.drop([importer_col], axis = 1, inplace = True)
        intranational.rename(columns= {exporter_col:self.labels.identifier,
                                       bsln_modeled_trade_label:bsln_intra_label,
                                       exper_trade_label:exper_intra_label,
                                       trade_change_label:intra_change_label}, inplace = True)

        agg_trade = agg_trade.merge(intranational, on = self.labels.identifier)

        # Store values in each country object
        for row in agg_trade.index:
            country = agg_trade.loc[row, self.labels.identifier]
            country_obj = self.country_set[country]
            country_obj.baseline_imports = agg_trade.loc[row, bsln_agg_imports_label]
            country_obj.baseline_exports = agg_trade.loc[row, bsln_agg_exports_label]
            country_obj.baseline_foreign_imports = agg_trade.loc[row, bsln_agg_frgn_imports_label]
            country_obj.baseline_foreign_exports = agg_trade.loc[row, bsln_agg_frgn_exports_label]
            country_obj.experiment_imports = agg_trade.loc[row, exper_agg_imports_label]
            country_obj.experiment_exports = agg_trade.loc[row, exper_agg_exports_label]
            country_obj.imports_change = agg_trade.loc[row, agg_import_change_label]
            country_obj.exports_change = agg_trade.loc[row, agg_exports_change_label]
            country_obj.experiment_foreign_imports = agg_trade.loc[row, exper_agg_frgn_imports_label]
            country_obj.experiment_foreign_exports = agg_trade.loc[row, exper_agg_frgn_exports_label]
            country_obj.foreign_imports_change = agg_trade.loc[row, agg_frgn_import_change_label]
            country_obj.foreign_exports_change = agg_trade.loc[row, agg_frgn_exports_change_label]
            country_obj.baseline_intranational_trade = agg_trade.loc[row, bsln_intra_label]
            country_obj.experiment_intranational_trade = agg_trade.loc[row, exper_intra_label]
            country_obj.intranational_trade_change = agg_trade.loc[row, intra_change_label]

        self.aggregate_trade_results = agg_trade.set_index(self.labels.identifier)

    def _compile_results(self):
        &#39;&#39;&#39;Generate and compile results after simulations&#39;&#39;&#39;
        results = list()
        mr_results = list()
        for country in self.country_set.keys():
            results.append(self.country_set[country].get_results(self.labels))
            mr_results.append(self.country_set[country].get_mr_results(self.labels))
        country_results = pd.concat(results, axis=0)
        self.country_results = country_results.set_index(self.labels.identifier)
        country_mr_results = pd.concat(mr_results, axis=0)
        self.country_mr_terms = country_mr_results.set_index(self.labels.identifier)


    def trade_share(self, importers: List[str], exporters: List[str]):
        &#39;&#39;&#39;
        Calculate baseline and experiment import and export shares (in percentages) between user-supplied countries.
        Args:
            importers (list[str]): A list of country codes to include as import partners.
            exporters (list[str]): A list of country codes to include as export partners.

        Returns:
            pandas.DataFrame: A dataframe expressing baseline, experiment, and changes in trade between each specified importer and exporter.
        &#39;&#39;&#39;
        # &#39;&#39;&#39;
        #
        # :param importers:  A list of country codes to include as import partners.
        # :param exporters: (list[str]) A list of country codes to include as export partners.
        # :return: (DataFrame)
        # &#39;&#39;&#39;
        importer_col = self.meta_data.imp_var_name
        exporter_col = self.meta_data.exp_var_name
        bsln_modeled_trade_label = self.labels.baseline_modeled_trade
        exper_trade_label = self.labels.experiment_trade

        bilat_trade = self.bilateral_trade_results.reset_index()
        columns = [bsln_modeled_trade_label, exper_trade_label]
        imports = bilat_trade.loc[bilat_trade[importer_col].isin(importers), :].copy()
        exports = bilat_trade.loc[bilat_trade[&#39;exporter&#39;].isin(exporters), :].copy()

        total_imports = imports[columns].agg(&#39;sum&#39;)
        total_exports = exports[columns].agg(&#39;sum&#39;)

        selected_imports = imports.loc[imports[&#39;exporter&#39;].isin(exporters), columns].copy().agg(&#39;sum&#39;)
        selected_exports = exports.loc[exports[importer_col].isin(importers), columns].copy().agg(&#39;sum&#39;)

        import_data = 100 * selected_imports / total_imports
        export_data = 100 * selected_exports / total_exports

        import_data[&#39;description&#39;] = &#39;Percent of &#39; + &#34;, &#34;.join(importers) + &#39; imports from &#39; + &#34;, &#34;.join(exporters)
        export_data[&#39;description&#39;] = &#39;Percent of &#39; + &#34;, &#34;.join(exporters) + &#39; exports to &#39; + &#34;, &#34;.join(importers)

        both = pd.concat([import_data, export_data], axis=1).T
        both = both[[&#39;description&#39;] + columns]
        both[&#39;change (percentage point)&#39;] = (both[exper_trade_label] - both[bsln_modeled_trade_label])
        both[&#39;change (%)&#39;] = 100 * (both[exper_trade_label] - both[bsln_modeled_trade_label]) / \
                                   both[bsln_modeled_trade_label]

        return both

    def export_results(self, directory:str = None, name:str = &#39;&#39;,
                       include_levels:bool = False, country_names:DataFrame = None):
        &#39;&#39;&#39;
        Export results to csv files. Three files are stored containing (1) country-level results, (2) bilateral results,
        and (3) solver diagnostics.
        Args:
            directory (str): (optional) Directory in which to write results files. If no directory is supplied,
                three compiled dataframes are returned as a tuple in the order (Country-level results, bilateral
                results, solver diagnostics).
            name (str): (optional) Name of the simulation to prefix to the result file names.
            include_levels (bool): (optional) If True, includes additional columns reflecting the simulated changes in
                levels based on observed trade flows (rather than modeled trade flows). Values are those from the
                method calculate_levels.
            country_names (pandas.DataFrame): (optional) Adds alternative identifiers such as names to the returned
                results tables. The supplied DataFrame should include exactly two columns. The first column must be
                the country identifiers used in the model. The second column must be the alternative identifiers to
                add.

        Returns:
            None or Tuple[DataFrame, DataFrame, DataFrame]: If a directory argument is supplied, the method returns
                nothing and writes three .csv files instead. If no directory is supplied, it returns a tuple of DataFrames.
        &#39;&#39;&#39;

        importer_col = self.meta_data.imp_var_name
        exporter_col = self.meta_data.exp_var_name

        country_result_set = [self.country_results, self.factory_gate_prices, self.aggregate_trade_results,
                              self.outputs_expenditures, self.country_mr_terms]
        country_results = pd.concat(country_result_set, axis = 1)
        # Order and select columns for inclusion, drop duplicates.
        country_results_cols = country_results.columns
        labs = self.labels
        # Country results to include
        results_cols = self.labels.country_level_labels

        included_columns = [col for col in results_cols if col in country_results_cols]
        country_results = country_results[included_columns]
        country_results = country_results.loc[:, ~country_results.columns.duplicated()]

        bilateral_results = self.bilateral_trade_results.reset_index()

        if include_levels:
            country_levels = self.calculate_levels(how = &#39;country&#39;)
            duplicate_columns = [col for col in country_levels.columns if col in country_results.columns]
            country_levels.drop(duplicate_columns,axis = 1, inplace = True)
            country_results = country_results.merge(country_levels, how = &#39;left&#39;, left_index = True, right_index = True)

            bilateral_levels = self.calculate_levels(how=&#39;bilateral&#39;)
            duplicate_columns = [col for col in bilateral_levels.columns if (col in bilateral_results.columns)
                                 and col not in [exporter_col, importer_col]]
            bilateral_levels.drop(duplicate_columns, axis=1, inplace=True)
            bilateral_results = bilateral_results.merge(bilateral_levels, how=&#39;left&#39;, on = [exporter_col, importer_col])

        if country_names is not None:
            if country_names.shape[1]!=2:
                raise ValueError(&#34;country_names should have exactly 2 columns, not {}&#34;.format(country_names.shape[1]))
            code_col = country_names.columns[0]
            name_col = country_names.columns[1]
            country_names.set_index(code_col, inplace = True, drop = True)
            country_results = country_names.merge(country_results, how = &#39;right&#39;, left_index = True, right_index=True)

            # Add names to bilateral data
            for side in [exporter_col, importer_col]:
                side_names = country_names.copy()
                side_names.reset_index(inplace = True)
                side_names.rename(columns = {code_col:side, name_col:&#34;{} {}&#34;.format(side,name_col)}, inplace = True)
                bilateral_results = bilateral_results.merge(side_names, how = &#39;left&#39;, on = side)





        # Create Dataframe with Diagnostic results
        diagnostics = self.solver_diagnostics
        column_list = list()
        # Iterate through the three solver types: baseline_MRs, conditional_MRs, and Full_GE
        for results_type, results in diagnostics.items():
            for key, value in results.items():
                # Single Entry fields must be converted to list before creating DataFrame
                if key in [&#39;success&#39;, &#39;status&#39;, &#39;nfev&#39;, &#39;message&#39;]:
                    frame = pd.DataFrame({(results_type, key): [value]})
                    column_list.append(frame)
                # Vector-like fields Can be used as is. Several available fields are not included: &#39;fjac&#39;,&#39;r&#39;, and &#39;qtf&#39;
                elif key in [&#39;x&#39;, &#39;fun&#39;]:
                    frame = pd.DataFrame({(results_type, key): value})
                    column_list.append(frame)
        diag_frame = pd.concat(column_list, axis=1)
        diag_frame = diag_frame.fillna(&#39;&#39;)


        if directory is not None:
            country_results.to_csv(&#34;{}/{}_country_results.csv&#34;.format(directory, name))
            bilateral_results.to_csv(&#34;{}/{}_bilateral_results.csv&#34;.format(directory, name), index = False)
            diag_frame.to_csv(&#34;{}/{}_solver_diagnostics.csv&#34;.format(directory, name), index = False)
        else:
            return country_results, bilateral_results, diagnostics

    def calculate_levels(self, how: str = &#39;country&#39;):
        &#39;&#39;&#39;
        Calculate changes in the level (value) of trade using baseline trade values and simulation outcomes. Results
            can be calculated at either the country level or bilateral level.
        Args:
            how (str):  If &#39;country&#39;, returned values are calculated at the country level (total exports, imports,
                and intranational). If &#39;bilateral&#39;, returned results are at the bilateral level. Default is &#39;country&#39;.

        Returns:
            pandas.DataFrame: A DataFrame containing baseline and experiment trade levels as well as the change expressed
                in levels and percentages. If calculated at the country level, these four measures are each returned for
                total imports, exports, and intranational trade. If calculated at the bilateral level, only one set of the
                measures is returned.
        &#39;&#39;&#39;
        if not self._baseline_built and self._experiment_defined:
            raise ValueError(&#39;Model must be fully solved before calculating levels.&#39;)
        exporter = self.meta_data.exp_var_name
        importer = self.meta_data.imp_var_name
        trade = self.meta_data.trade_var_name
        trade_flows = self.baseline_data.copy()
        trade_flows = trade_flows[[exporter, importer, trade]]
        bilateral_results = self.bilateral_trade_results[[self.labels.trade_change]].copy()
        bilateral_results.reset_index(inplace=True)
        #crl = country_results_labels

        # Coumpute at the country level (importer, exporter, and intranational)
        if how == &#39;country&#39;:
            intra_national = trade_flows.loc[trade_flows[exporter] == trade_flows[importer], [exporter, trade]]
            intra_national.set_index(exporter, inplace=True)
            international = trade_flows.loc[trade_flows[exporter] != trade_flows[importer], :]
            # Aggregate trade values
            foreign_exports = international.groupby(exporter).agg({trade: &#39;sum&#39;})
            foreign_imports = international.groupby(importer).agg({trade: &#39;sum&#39;})
            # Combine
            country_trade = foreign_exports.merge(foreign_imports, how=&#39;outer&#39;, left_index=True, right_index=True)
            country_trade = country_trade.merge(intra_national, how=&#39;outer&#39;, left_index=True, right_index=True)
            country_trade.columns = [self.labels.baseline_observed_foreign_exports,
                                     self.labels.baseline_observed_foreign_imports,
                                     self.labels.baseline_observed_intranational_trade]

            # Prep and add experiment change info
            experiment_results = self.country_results[[self.labels.foreign_exports_change,
                                                       self.labels.foreign_imports_change]].reset_index()
            intra_results = bilateral_results.loc[bilateral_results[exporter] == bilateral_results[importer],
                                                  [exporter, self.labels.trade_change]].copy()
            intra_results.rename(columns={exporter: &#39;country&#39;,
                                          self.labels.trade_change: self.labels.intranational_trade_change},
                                          inplace=True)
            experiment_results = pd.merge(experiment_results, intra_results, on=self.labels.identifier)
            experiment_results.set_index(self.labels.identifier, inplace=True)
            country_trade = country_trade.merge(experiment_results, how=&#39;outer&#39;, left_index=True, right_index=True)
            # Compute new levels
            for level, change in [(self.labels.baseline_observed_foreign_exports, self.labels.foreign_exports_change),
                                  (self.labels.baseline_observed_foreign_imports, self.labels.foreign_imports_change),
                                  (self.labels.baseline_observed_intranational_trade, self.labels.intranational_trade_change)]:

                new_level_name = level.replace(&#39;baseline&#39;, &#39;experiment&#39;)
                level_change_name = change.replace(&#39;%&#39;,&#39;observed level&#39;)
                country_trade[new_level_name] = country_trade[level] * (1 + (experiment_results[change] / 100))
                country_trade[level_change_name] = country_trade[new_level_name] - country_trade[level]

            result_order = list()
            for result_type in [&#39;exports&#39;,&#39;imports&#39;,&#39;intranational&#39;]:
                for sub_type in [&#39;baseline&#39;,&#39;experiment&#39;,&#39;level&#39;,&#39;%&#39;]:
                    for col in country_trade.columns:
                        if (sub_type in col) and (result_type in col):
                            result_order.append(col)

            return country_trade[result_order]
        # Compute at the bilateral level
        if how == &#39;bilateral&#39;:
            # Prep and add experiment change info
            experiment_results = bilateral_results
            bilat_trade = trade_flows.merge(experiment_results, on=[exporter, importer], how=&#39;outer&#39;)
            bilat_trade.rename(columns={trade: self.labels.baseline_observed_trade},
                               inplace=True)
            # Create changes in levels

            bilat_trade[self.labels.experiment_observed_trade] = bilat_trade[self.labels.baseline_observed_trade] * (
                        1 + (bilat_trade[self.labels.trade_change] / 100))
            bilat_trade[self.labels.trade_change_level] = bilat_trade[self.labels.experiment_observed_trade] - bilat_trade[self.labels.baseline_observed_trade]
            bilat_trade = bilat_trade[[exporter, importer, self.labels.baseline_observed_trade,
                                       self.labels.experiment_observed_trade, self.labels.trade_change_level, self.labels.trade_change]]
            return bilat_trade

    def trade_weighted_shock(self, how:str = &#39;country&#39;, aggregations:list=[&#39;mean&#39;, &#39;sum&#39;, &#39;max&#39;]):
        &#39;&#39;&#39;
        Create measures of trade weighted policy shocks to better understand which countries are most affected. Results
        reflect the absolute value of the change in trade costs multiplied by the
        Args:
            how (str): Determines the level of the results. If &#39;country&#39;, weighted shocks are returned at the country
                level for both importer and exporter using specified methods of aggregation. If &#39;bilateral&#39;, it returns the
                weighted shocks for all bilateral pairs. Default is &#39;country&#39;.
            aggregations (list[str]):  A list of methods by which to aggregate weighted shocks if how = &#39;country&#39;.
                List entries must be selected from those that are functional with the pandas.DataFrame.agg() method. The
                default value is [&#39;mean&#39;, &#39;sum&#39;, &#39;max&#39;].
        Returns:
            pandas.DataFrame: A dataframe of trade-weighted trade cost shocks.
        &#39;&#39;&#39;
        # Collect needed results
        bilat_trade = self.bilateral_trade_results.copy()
        bilat_trade.reset_index(inplace=True)
        cost_shock = self.cost_shock.copy()

        # Define column names
        imp_col = self.meta_data.imp_var_name
        exp_col = self.meta_data.exp_var_name
        baseline_trade_col = self.labels.baseline_modeled_trade
        baseline_cost_col = &#39;baseline_trade_cost&#39;
        exper_cost_col = &#39;experiment_trade_cost&#39;
        cost_change = &#39;cost_change&#39;
        weighted_col = &#39;weighted_shock&#39;

        # Create change in costs and add to bilateral trade
        cost_shock[cost_change] = abs(cost_shock[exper_cost_col] - cost_shock[baseline_cost_col])
        trade_shock = bilat_trade.merge(cost_shock, how=&#39;left&#39;, on=[imp_col, exp_col])
        trade_shock = trade_shock[[exp_col, imp_col, baseline_trade_col, cost_change]]
        # Fill cases with no change in costs with zero
        trade_shock.fillna(0, inplace=True)
        # Calculate weighted costs and normalize my largest weighted shock
        trade_shock[weighted_col] = trade_shock[baseline_trade_col] * trade_shock[cost_change]
        max_shock = max(trade_shock[weighted_col])
        trade_shock[weighted_col] = trade_shock[weighted_col] / max_shock

        # Create aggregate measures at importer and exporter level
        exporter_shocks = trade_shock.groupby(exp_col).agg({weighted_col: aggregations})
        exporter_shocks.columns = pd.MultiIndex.from_product(exporter_shocks.columns.levels + [[exp_col]])
        importer_shocks = trade_shock.groupby(imp_col).agg({weighted_col: aggregations})
        importer_shocks.columns = pd.MultiIndex.from_product(importer_shocks.columns.levels + [[imp_col]])
        weighted_shocks = pd.concat([exporter_shocks, importer_shocks], axis=1)

        if how == &#39;country&#39;:
            return weighted_shocks
        if how == &#39;bilateral&#39;:
            return trade_shock


    # ---
    # Diagnostic Tools
    # ---
    def test_baseline_mr_function(self, inputs_only:bool=False):
        &#39;&#39;&#39;
        Test whether the multilateral resistance system of equations can be computed from baseline data. Helpful for
            debugging initial data problems. Note that the returned function values reflect those generated by the
            initial values and do not reflect a solution to the system.
        Args:
            inputs_only (bool): If False (default), the method tests the computability of the MR system of equations
                and returns both the inputs to the system and the output. If True, only the system inputs are return and
                the equations are not computed and can help diagnose input issues that raise errors.
        Returns:
            dict: A dictionary containing a collection of parameter and value inputs as well as the function
                values at the initial values.
        &#39;&#39;&#39;
        test_diagnostics = self._calculate_multilateral_resistance(trade_costs=self.baseline_trade_costs,
                                                                   version=&#39;baseline&#39;, test=True,
                                                                   inputs_only=inputs_only)
        return test_diagnostics

    def check_omr_rescale(self,
                         omr_rescale_range:int = 10,
                         mr_method: str = &#39;hybr&#39;,
                         mr_max_iter: int = 1400,
                         mr_tolerance: float = 1e-8,
                         countries:List[str] = []):
        &#39;&#39;&#39;
        Analyze different Outward Multilarteral Resistance (OMR) term rescale factors. This method can help identify
            feasible values to use for the omr_rescale argument in OneSectorGE.build_baseline().
        Args:
            omr_rescale_range (int): This parameter allows you to set the scope of the values tested. For example,
                if omr_rescale_range = 3, the model will check for convergence using omr_rescale values from the set
                [10^-3, 10^-2, 10^-1, 10^0, ..., 10^3]. The default value is 10.
            mr_method (str): This parameter determines the type of non-linear solver used for solving the baseline and
                experiment MR terms. See the documentation for scipy.optimize.root for alternative methods. the default
                value is &#39;hybr&#39;.
            mr_max_iter (int): (optional) This parameter sets the maximum limit on the number of iterations conducted
                by the solver used to solve for MR terms. The default value is 1400.
            mr_tolerance (float): (optional) This parameterset the convergence tolerance level for the solver used to
                solve for MR terms. The default value is 1e-8.
            countries (List[str]):  A list of countries for which to return the estimated OMR values for user
                evaluation.
        Returns:
            pandas.DataFrame: A dataframe of diagnostic information for users to compare different omr_rescale factors.
                The returned dataframe contains the following columns:\n
                &#39;omr_rescale&#39;: The rescale factor used\n
                &#39;omr_rescale (alt format)&#39;: A string representation of the rescale factor as an exponential expression.\n
                &#39;solved&#39;: If True, the MR model solved successfully. If False, it did not solve.\n
                &#39;message&#39;: Description of the outcome of the solver.\n
                &#39;..._func_value&#39;: Three columns reflelcting the maximum, mean, and median values from the solver
                    objective functions. Function values closer to zero imply a better solution to system of equations.
                &#39;reference_importer_omr&#39;: The solution value for the reference importer&#39;s OMR value.\n
                &#39;..._omr&#39;: The solution value(s) for the user supplied countries.
        &#39;&#39;&#39;

        self._mr_max_iter = mr_max_iter
        self._mr_tolerance = mr_tolerance
        self._mr_method = mr_method
        self._imr_rescale = 1

        # Set up procedure for identifying usable omr_rescale
        findings = list()
        value_index = 0
        # Create list of rescale factors to test
        scale_values = range(-1*omr_rescale_range,omr_rescale_range+1)

        for scale_value in scale_values:
            value_results = dict()
            rescale_factor = 10 ** scale_value

            if not self.quiet:
                print(&#34;\nTrying OMR rescale factor of {}&#34;.format(rescale_factor))
            self._omr_rescale = rescale_factor
            self._calculate_multilateral_resistance(trade_costs=self.baseline_trade_costs,
                                                    version=&#39;baseline&#39;)
            value_results[&#39;omr_rescale&#39;] = rescale_factor
            value_results[&#39;omr_rescale (alt format)&#39;] = &#39;10^{}&#39;.format(scale_value)
            value_results[&#39;solved&#39;] = self.solver_diagnostics[&#39;baseline_MRs&#39;][&#39;success&#39;]
            value_results[&#39;message&#39;] = self.solver_diagnostics[&#39;baseline_MRs&#39;][&#39;message&#39;]
            func_vals = self.solver_diagnostics[&#39;baseline_MRs&#39;][&#39;fun&#39;]
            value_results[&#39;max_func_value&#39;] = func_vals.max()
            value_results[&#39;mean_func_value&#39;] = func_vals.mean()
            value_results[&#39;mean_func_value&#39;] = median(func_vals)
            value_results[&#39;reference_importer_omr&#39;] = self.country_set[self._reference_importer]._baseline_omr_ratio
            for country in countries:
                value_results[&#39;{}_omr&#39;.format(country)] = self.country_set[country]._baseline_omr_ratio
            findings.append(value_results)
        findings_table = pd.DataFrame(findings)

        return findings_table</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="models.OneSectorGE.OneSectorGE.build_baseline"><code class="name flex">
<span>def <span class="ident">build_baseline</span></span>(<span>self, omr_rescale: float = 1, imr_rescale: float = 1, mr_method: str = 'hybr', mr_max_iter: int = 1400, mr_tolerance: float = 1e-08)</span>
</code></dt>
<dd>
<div class="desc"><p>Solve the baseline model. This primarily solves for the baseline Multilateral Resistance (MR) terms.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>omr_rescale</code></strong> :&ensp;<code>int</code></dt>
<dd>(optional) This value rescales the OMR values to assist in convergence. Often, OMR values
are orders of magnitude different than IMR values, which can make convergence difficult. Scaling by a
different order of magnitude can help. Values should be of the form 10^n. By default, this value is 1
(10^0). However, users should be careful with this choice as results, even when convergent, may not be
fully robust to any selection. The method OneSectorGE.check_omr_rescale() can help identify and compare
feasible values.</dd>
<dt><strong><code>imr_rescale</code></strong> :&ensp;<code>int</code></dt>
<dd>(optional) This value rescales the IMR values to potentially aid in conversion. However,
because the IMR for the reference importer is normalized to one, it is unlikely that there will be because
because changing the default value, which is 1.</dd>
<dt><strong><code>mr_method</code></strong> :&ensp;<code>str</code></dt>
<dd>This parameter determines the type of non-linear solver used for solving the baseline and
experiment MR terms. See the documentation for scipy.optimize.root for alternative methods. the default
value is 'hybr'.</dd>
<dt><strong><code>mr_max_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>(optional) This parameter sets the maximum limit on the number of iterations conducted
by the solver used to solve for MR terms. The default value is 1400.</dd>
<dt><strong><code>mr_tolerance</code></strong> :&ensp;<code>float</code></dt>
<dd>(optional) This parameterset the convergence tolerance level for the solver used to
solve for MR terms. The default value is 1e-8.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>Populates Attributes of model object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_baseline(self,
                   omr_rescale: float = 1,
                   imr_rescale: float = 1,
                   mr_method: str = &#39;hybr&#39;,
                   mr_max_iter: int = 1400,
                   mr_tolerance: float = 1e-8):
    &#39;&#39;&#39;
    Solve the baseline model. This primarily solves for the baseline Multilateral Resistance (MR) terms.
    Args:
        omr_rescale (int): (optional) This value rescales the OMR values to assist in convergence. Often, OMR values
            are orders of magnitude different than IMR values, which can make convergence difficult. Scaling by a
            different order of magnitude can help. Values should be of the form 10^n. By default, this value is 1
            (10^0). However, users should be careful with this choice as results, even when convergent, may not be
            fully robust to any selection. The method OneSectorGE.check_omr_rescale() can help identify and compare
            feasible values.
        imr_rescale (int): (optional) This value rescales the IMR values to potentially aid in conversion. However,
            because the IMR for the reference importer is normalized to one, it is unlikely that there will be because
            because changing the default value, which is 1.
        mr_method (str): This parameter determines the type of non-linear solver used for solving the baseline and
            experiment MR terms. See the documentation for scipy.optimize.root for alternative methods. the default
            value is &#39;hybr&#39;.
        mr_max_iter (int): (optional) This parameter sets the maximum limit on the number of iterations conducted
            by the solver used to solve for MR terms. The default value is 1400.
        mr_tolerance (float): (optional) This parameterset the convergence tolerance level for the solver used to
            solve for MR terms. The default value is 1e-8.

    Returns:
        None: Populates Attributes of model object.
    &#39;&#39;&#39;
    self._omr_rescale = omr_rescale
    self._imr_rescale = imr_rescale
    self._mr_max_iter = mr_max_iter
    self._mr_tolerance = mr_tolerance
    self._mr_method = mr_method

    # Solve for the baseline multilateral resistance terms
    if self.approach == &#39;GEPPML&#39;:
        if self._estimation_results is None:
            raise ValueError(&#34;GEPPML approach requires that the gme.EstimationModel be estimated and use importer and exporter fixed effects.&#34;)
        self._calculate_GEPPML_multilateral_resistance(version=&#39;baseline&#39;)
    else:
        self._calculate_multilateral_resistance(trade_costs=self.baseline_trade_costs, version=&#39;baseline&#39;)
    # Calculate baseline factory gate prices
    self._calculate_baseline_factory_gate_params()
    self._baseline_built = True</code></pre>
</details>
</dd>
<dt id="models.OneSectorGE.OneSectorGE.calculate_levels"><code class="name flex">
<span>def <span class="ident">calculate_levels</span></span>(<span>self, how: str = 'country')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate changes in the level (value) of trade using baseline trade values and simulation outcomes. Results
can be calculated at either the country level or bilateral level.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>how</code></strong> :&ensp;<code>str</code></dt>
<dd>If 'country', returned values are calculated at the country level (total exports, imports,
and intranational). If 'bilateral', returned results are at the bilateral level. Default is 'country'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>A DataFrame containing baseline and experiment trade levels as well as the change expressed
in levels and percentages. If calculated at the country level, these four measures are each returned for
total imports, exports, and intranational trade. If calculated at the bilateral level, only one set of the
measures is returned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_levels(self, how: str = &#39;country&#39;):
    &#39;&#39;&#39;
    Calculate changes in the level (value) of trade using baseline trade values and simulation outcomes. Results
        can be calculated at either the country level or bilateral level.
    Args:
        how (str):  If &#39;country&#39;, returned values are calculated at the country level (total exports, imports,
            and intranational). If &#39;bilateral&#39;, returned results are at the bilateral level. Default is &#39;country&#39;.

    Returns:
        pandas.DataFrame: A DataFrame containing baseline and experiment trade levels as well as the change expressed
            in levels and percentages. If calculated at the country level, these four measures are each returned for
            total imports, exports, and intranational trade. If calculated at the bilateral level, only one set of the
            measures is returned.
    &#39;&#39;&#39;
    if not self._baseline_built and self._experiment_defined:
        raise ValueError(&#39;Model must be fully solved before calculating levels.&#39;)
    exporter = self.meta_data.exp_var_name
    importer = self.meta_data.imp_var_name
    trade = self.meta_data.trade_var_name
    trade_flows = self.baseline_data.copy()
    trade_flows = trade_flows[[exporter, importer, trade]]
    bilateral_results = self.bilateral_trade_results[[self.labels.trade_change]].copy()
    bilateral_results.reset_index(inplace=True)
    #crl = country_results_labels

    # Coumpute at the country level (importer, exporter, and intranational)
    if how == &#39;country&#39;:
        intra_national = trade_flows.loc[trade_flows[exporter] == trade_flows[importer], [exporter, trade]]
        intra_national.set_index(exporter, inplace=True)
        international = trade_flows.loc[trade_flows[exporter] != trade_flows[importer], :]
        # Aggregate trade values
        foreign_exports = international.groupby(exporter).agg({trade: &#39;sum&#39;})
        foreign_imports = international.groupby(importer).agg({trade: &#39;sum&#39;})
        # Combine
        country_trade = foreign_exports.merge(foreign_imports, how=&#39;outer&#39;, left_index=True, right_index=True)
        country_trade = country_trade.merge(intra_national, how=&#39;outer&#39;, left_index=True, right_index=True)
        country_trade.columns = [self.labels.baseline_observed_foreign_exports,
                                 self.labels.baseline_observed_foreign_imports,
                                 self.labels.baseline_observed_intranational_trade]

        # Prep and add experiment change info
        experiment_results = self.country_results[[self.labels.foreign_exports_change,
                                                   self.labels.foreign_imports_change]].reset_index()
        intra_results = bilateral_results.loc[bilateral_results[exporter] == bilateral_results[importer],
                                              [exporter, self.labels.trade_change]].copy()
        intra_results.rename(columns={exporter: &#39;country&#39;,
                                      self.labels.trade_change: self.labels.intranational_trade_change},
                                      inplace=True)
        experiment_results = pd.merge(experiment_results, intra_results, on=self.labels.identifier)
        experiment_results.set_index(self.labels.identifier, inplace=True)
        country_trade = country_trade.merge(experiment_results, how=&#39;outer&#39;, left_index=True, right_index=True)
        # Compute new levels
        for level, change in [(self.labels.baseline_observed_foreign_exports, self.labels.foreign_exports_change),
                              (self.labels.baseline_observed_foreign_imports, self.labels.foreign_imports_change),
                              (self.labels.baseline_observed_intranational_trade, self.labels.intranational_trade_change)]:

            new_level_name = level.replace(&#39;baseline&#39;, &#39;experiment&#39;)
            level_change_name = change.replace(&#39;%&#39;,&#39;observed level&#39;)
            country_trade[new_level_name] = country_trade[level] * (1 + (experiment_results[change] / 100))
            country_trade[level_change_name] = country_trade[new_level_name] - country_trade[level]

        result_order = list()
        for result_type in [&#39;exports&#39;,&#39;imports&#39;,&#39;intranational&#39;]:
            for sub_type in [&#39;baseline&#39;,&#39;experiment&#39;,&#39;level&#39;,&#39;%&#39;]:
                for col in country_trade.columns:
                    if (sub_type in col) and (result_type in col):
                        result_order.append(col)

        return country_trade[result_order]
    # Compute at the bilateral level
    if how == &#39;bilateral&#39;:
        # Prep and add experiment change info
        experiment_results = bilateral_results
        bilat_trade = trade_flows.merge(experiment_results, on=[exporter, importer], how=&#39;outer&#39;)
        bilat_trade.rename(columns={trade: self.labels.baseline_observed_trade},
                           inplace=True)
        # Create changes in levels

        bilat_trade[self.labels.experiment_observed_trade] = bilat_trade[self.labels.baseline_observed_trade] * (
                    1 + (bilat_trade[self.labels.trade_change] / 100))
        bilat_trade[self.labels.trade_change_level] = bilat_trade[self.labels.experiment_observed_trade] - bilat_trade[self.labels.baseline_observed_trade]
        bilat_trade = bilat_trade[[exporter, importer, self.labels.baseline_observed_trade,
                                   self.labels.experiment_observed_trade, self.labels.trade_change_level, self.labels.trade_change]]
        return bilat_trade</code></pre>
</details>
</dd>
<dt id="models.OneSectorGE.OneSectorGE.check_omr_rescale"><code class="name flex">
<span>def <span class="ident">check_omr_rescale</span></span>(<span>self, omr_rescale_range: int = 10, mr_method: str = 'hybr', mr_max_iter: int = 1400, mr_tolerance: float = 1e-08, countries: List[str] = [])</span>
</code></dt>
<dd>
<div class="desc"><p>Analyze different Outward Multilarteral Resistance (OMR) term rescale factors. This method can help identify
feasible values to use for the omr_rescale argument in OneSectorGE.build_baseline().</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>omr_rescale_range</code></strong> :&ensp;<code>int</code></dt>
<dd>This parameter allows you to set the scope of the values tested. For example,
if omr_rescale_range = 3, the model will check for convergence using omr_rescale values from the set
[10^-3, 10^-2, 10^-1, 10^0, &hellip;, 10^3]. The default value is 10.</dd>
<dt><strong><code>mr_method</code></strong> :&ensp;<code>str</code></dt>
<dd>This parameter determines the type of non-linear solver used for solving the baseline and
experiment MR terms. See the documentation for scipy.optimize.root for alternative methods. the default
value is 'hybr'.</dd>
<dt><strong><code>mr_max_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>(optional) This parameter sets the maximum limit on the number of iterations conducted
by the solver used to solve for MR terms. The default value is 1400.</dd>
<dt><strong><code>mr_tolerance</code></strong> :&ensp;<code>float</code></dt>
<dd>(optional) This parameterset the convergence tolerance level for the solver used to
solve for MR terms. The default value is 1e-8.</dd>
<dt><strong><code>countries</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>A list of countries for which to return the estimated OMR values for user
evaluation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>
<p>A dataframe of diagnostic information for users to compare different omr_rescale factors.
The returned dataframe contains the following columns:</p>
<p>'omr_rescale': The rescale factor used</p>
<p>'omr_rescale (alt format)': A string representation of the rescale factor as an exponential expression.</p>
<p>'solved': If True, the MR model solved successfully. If False, it did not solve.</p>
<p>'message': Description of the outcome of the solver.</p>
<p>'&hellip;_func_value': Three columns reflelcting the maximum, mean, and median values from the solver
objective functions. Function values closer to zero imply a better solution to system of equations.
'reference_importer_omr': The solution value for the reference importer's OMR value.</p>
<p>'&hellip;_omr': The solution value(s) for the user supplied countries.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_omr_rescale(self,
                     omr_rescale_range:int = 10,
                     mr_method: str = &#39;hybr&#39;,
                     mr_max_iter: int = 1400,
                     mr_tolerance: float = 1e-8,
                     countries:List[str] = []):
    &#39;&#39;&#39;
    Analyze different Outward Multilarteral Resistance (OMR) term rescale factors. This method can help identify
        feasible values to use for the omr_rescale argument in OneSectorGE.build_baseline().
    Args:
        omr_rescale_range (int): This parameter allows you to set the scope of the values tested. For example,
            if omr_rescale_range = 3, the model will check for convergence using omr_rescale values from the set
            [10^-3, 10^-2, 10^-1, 10^0, ..., 10^3]. The default value is 10.
        mr_method (str): This parameter determines the type of non-linear solver used for solving the baseline and
            experiment MR terms. See the documentation for scipy.optimize.root for alternative methods. the default
            value is &#39;hybr&#39;.
        mr_max_iter (int): (optional) This parameter sets the maximum limit on the number of iterations conducted
            by the solver used to solve for MR terms. The default value is 1400.
        mr_tolerance (float): (optional) This parameterset the convergence tolerance level for the solver used to
            solve for MR terms. The default value is 1e-8.
        countries (List[str]):  A list of countries for which to return the estimated OMR values for user
            evaluation.
    Returns:
        pandas.DataFrame: A dataframe of diagnostic information for users to compare different omr_rescale factors.
            The returned dataframe contains the following columns:\n
            &#39;omr_rescale&#39;: The rescale factor used\n
            &#39;omr_rescale (alt format)&#39;: A string representation of the rescale factor as an exponential expression.\n
            &#39;solved&#39;: If True, the MR model solved successfully. If False, it did not solve.\n
            &#39;message&#39;: Description of the outcome of the solver.\n
            &#39;..._func_value&#39;: Three columns reflelcting the maximum, mean, and median values from the solver
                objective functions. Function values closer to zero imply a better solution to system of equations.
            &#39;reference_importer_omr&#39;: The solution value for the reference importer&#39;s OMR value.\n
            &#39;..._omr&#39;: The solution value(s) for the user supplied countries.
    &#39;&#39;&#39;

    self._mr_max_iter = mr_max_iter
    self._mr_tolerance = mr_tolerance
    self._mr_method = mr_method
    self._imr_rescale = 1

    # Set up procedure for identifying usable omr_rescale
    findings = list()
    value_index = 0
    # Create list of rescale factors to test
    scale_values = range(-1*omr_rescale_range,omr_rescale_range+1)

    for scale_value in scale_values:
        value_results = dict()
        rescale_factor = 10 ** scale_value

        if not self.quiet:
            print(&#34;\nTrying OMR rescale factor of {}&#34;.format(rescale_factor))
        self._omr_rescale = rescale_factor
        self._calculate_multilateral_resistance(trade_costs=self.baseline_trade_costs,
                                                version=&#39;baseline&#39;)
        value_results[&#39;omr_rescale&#39;] = rescale_factor
        value_results[&#39;omr_rescale (alt format)&#39;] = &#39;10^{}&#39;.format(scale_value)
        value_results[&#39;solved&#39;] = self.solver_diagnostics[&#39;baseline_MRs&#39;][&#39;success&#39;]
        value_results[&#39;message&#39;] = self.solver_diagnostics[&#39;baseline_MRs&#39;][&#39;message&#39;]
        func_vals = self.solver_diagnostics[&#39;baseline_MRs&#39;][&#39;fun&#39;]
        value_results[&#39;max_func_value&#39;] = func_vals.max()
        value_results[&#39;mean_func_value&#39;] = func_vals.mean()
        value_results[&#39;mean_func_value&#39;] = median(func_vals)
        value_results[&#39;reference_importer_omr&#39;] = self.country_set[self._reference_importer]._baseline_omr_ratio
        for country in countries:
            value_results[&#39;{}_omr&#39;.format(country)] = self.country_set[country]._baseline_omr_ratio
        findings.append(value_results)
    findings_table = pd.DataFrame(findings)

    return findings_table</code></pre>
</details>
</dd>
<dt id="models.OneSectorGE.OneSectorGE.define_experiment"><code class="name flex">
<span>def <span class="ident">define_experiment</span></span>(<span>self, experiment_data: pandas.core.frame.DataFrame)</span>
</code></dt>
<dd>
<div class="desc"><p>Specify the counterfactual data to use for experiment.</p>
<h2 id="args">Args</h2>
<p>experiment_data(Pandas.DataFrame): A dataframe contianing the counterfactual trade-cost data to use for the
experiment. The best approach for creating this data is to copy the baseline data
(OneSectorGE.baseline_data.copy()) and modify columns/rows to reflect desired counterfactual experiment.</p>
<h2 id="returns">Returns</h2>
<p>None:
There is no return but the new information is added to model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_experiment(self, experiment_data: DataFrame):
    &#39;&#39;&#39;
    Specify the counterfactual data to use for experiment.
    Args:
        experiment_data(Pandas.DataFrame): A dataframe contianing the counterfactual trade-cost data to use for the
            experiment. The best approach for creating this data is to copy the baseline data
            (OneSectorGE.baseline_data.copy()) and modify columns/rows to reflect desired counterfactual experiment.

    Returns:
        None:
            There is no return but the new information is added to model.
    &#39;&#39;&#39;
    if not self._baseline_built:
        raise ValueError(&#34;Baseline must be built first (i.e. ge_model.build_baseline() method&#34;)
    self.experiment_data = experiment_data
    self.experiment_trade_costs = self._create_trade_costs(self.experiment_data)
    cost_change = self.baseline_trade_costs.merge(right=self.experiment_trade_costs, how=&#39;outer&#39;,
                                                  on=[self.meta_data.imp_var_name,
                                                      self.meta_data.exp_var_name,
                                                      self.meta_data.year_var_name])
    cost_change.rename(columns={&#39;trade_cost_x&#39;: &#39;baseline_trade_cost&#39;, &#39;trade_cost_y&#39;: &#39;experiment_trade_cost&#39;},
                       inplace=True)
    self.cost_shock = cost_change.loc[cost_change[&#39;baseline_trade_cost&#39;] != cost_change[&#39;experiment_trade_cost&#39;]]
    self._experiment_defined = True</code></pre>
</details>
</dd>
<dt id="models.OneSectorGE.OneSectorGE.export_results"><code class="name flex">
<span>def <span class="ident">export_results</span></span>(<span>self, directory: str = None, name: str = '', include_levels: bool = False, country_names: pandas.core.frame.DataFrame = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Export results to csv files. Three files are stored containing (1) country-level results, (2) bilateral results,
and (3) solver diagnostics.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>directory</code></strong> :&ensp;<code>str</code></dt>
<dd>(optional) Directory in which to write results files. If no directory is supplied,
three compiled dataframes are returned as a tuple in the order (Country-level results, bilateral
results, solver diagnostics).</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>(optional) Name of the simulation to prefix to the result file names.</dd>
<dt><strong><code>include_levels</code></strong> :&ensp;<code>bool</code></dt>
<dd>(optional) If True, includes additional columns reflecting the simulated changes in
levels based on observed trade flows (rather than modeled trade flows). Values are those from the
method calculate_levels.</dd>
<dt><strong><code>country_names</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>(optional) Adds alternative identifiers such as names to the returned
results tables. The supplied DataFrame should include exactly two columns. The first column must be
the country identifiers used in the model. The second column must be the alternative identifiers to
add.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code> or <code>Tuple[DataFrame, DataFrame, DataFrame]</code></dt>
<dd>If a directory argument is supplied, the method returns
nothing and writes three .csv files instead. If no directory is supplied, it returns a tuple of DataFrames.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_results(self, directory:str = None, name:str = &#39;&#39;,
                   include_levels:bool = False, country_names:DataFrame = None):
    &#39;&#39;&#39;
    Export results to csv files. Three files are stored containing (1) country-level results, (2) bilateral results,
    and (3) solver diagnostics.
    Args:
        directory (str): (optional) Directory in which to write results files. If no directory is supplied,
            three compiled dataframes are returned as a tuple in the order (Country-level results, bilateral
            results, solver diagnostics).
        name (str): (optional) Name of the simulation to prefix to the result file names.
        include_levels (bool): (optional) If True, includes additional columns reflecting the simulated changes in
            levels based on observed trade flows (rather than modeled trade flows). Values are those from the
            method calculate_levels.
        country_names (pandas.DataFrame): (optional) Adds alternative identifiers such as names to the returned
            results tables. The supplied DataFrame should include exactly two columns. The first column must be
            the country identifiers used in the model. The second column must be the alternative identifiers to
            add.

    Returns:
        None or Tuple[DataFrame, DataFrame, DataFrame]: If a directory argument is supplied, the method returns
            nothing and writes three .csv files instead. If no directory is supplied, it returns a tuple of DataFrames.
    &#39;&#39;&#39;

    importer_col = self.meta_data.imp_var_name
    exporter_col = self.meta_data.exp_var_name

    country_result_set = [self.country_results, self.factory_gate_prices, self.aggregate_trade_results,
                          self.outputs_expenditures, self.country_mr_terms]
    country_results = pd.concat(country_result_set, axis = 1)
    # Order and select columns for inclusion, drop duplicates.
    country_results_cols = country_results.columns
    labs = self.labels
    # Country results to include
    results_cols = self.labels.country_level_labels

    included_columns = [col for col in results_cols if col in country_results_cols]
    country_results = country_results[included_columns]
    country_results = country_results.loc[:, ~country_results.columns.duplicated()]

    bilateral_results = self.bilateral_trade_results.reset_index()

    if include_levels:
        country_levels = self.calculate_levels(how = &#39;country&#39;)
        duplicate_columns = [col for col in country_levels.columns if col in country_results.columns]
        country_levels.drop(duplicate_columns,axis = 1, inplace = True)
        country_results = country_results.merge(country_levels, how = &#39;left&#39;, left_index = True, right_index = True)

        bilateral_levels = self.calculate_levels(how=&#39;bilateral&#39;)
        duplicate_columns = [col for col in bilateral_levels.columns if (col in bilateral_results.columns)
                             and col not in [exporter_col, importer_col]]
        bilateral_levels.drop(duplicate_columns, axis=1, inplace=True)
        bilateral_results = bilateral_results.merge(bilateral_levels, how=&#39;left&#39;, on = [exporter_col, importer_col])

    if country_names is not None:
        if country_names.shape[1]!=2:
            raise ValueError(&#34;country_names should have exactly 2 columns, not {}&#34;.format(country_names.shape[1]))
        code_col = country_names.columns[0]
        name_col = country_names.columns[1]
        country_names.set_index(code_col, inplace = True, drop = True)
        country_results = country_names.merge(country_results, how = &#39;right&#39;, left_index = True, right_index=True)

        # Add names to bilateral data
        for side in [exporter_col, importer_col]:
            side_names = country_names.copy()
            side_names.reset_index(inplace = True)
            side_names.rename(columns = {code_col:side, name_col:&#34;{} {}&#34;.format(side,name_col)}, inplace = True)
            bilateral_results = bilateral_results.merge(side_names, how = &#39;left&#39;, on = side)





    # Create Dataframe with Diagnostic results
    diagnostics = self.solver_diagnostics
    column_list = list()
    # Iterate through the three solver types: baseline_MRs, conditional_MRs, and Full_GE
    for results_type, results in diagnostics.items():
        for key, value in results.items():
            # Single Entry fields must be converted to list before creating DataFrame
            if key in [&#39;success&#39;, &#39;status&#39;, &#39;nfev&#39;, &#39;message&#39;]:
                frame = pd.DataFrame({(results_type, key): [value]})
                column_list.append(frame)
            # Vector-like fields Can be used as is. Several available fields are not included: &#39;fjac&#39;,&#39;r&#39;, and &#39;qtf&#39;
            elif key in [&#39;x&#39;, &#39;fun&#39;]:
                frame = pd.DataFrame({(results_type, key): value})
                column_list.append(frame)
    diag_frame = pd.concat(column_list, axis=1)
    diag_frame = diag_frame.fillna(&#39;&#39;)


    if directory is not None:
        country_results.to_csv(&#34;{}/{}_country_results.csv&#34;.format(directory, name))
        bilateral_results.to_csv(&#34;{}/{}_bilateral_results.csv&#34;.format(directory, name), index = False)
        diag_frame.to_csv(&#34;{}/{}_solver_diagnostics.csv&#34;.format(directory, name), index = False)
    else:
        return country_results, bilateral_results, diagnostics</code></pre>
</details>
</dd>
<dt id="models.OneSectorGE.OneSectorGE.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>self, ge_method: str = 'hybr', ge_tolerance: float = 1e-08, ge_max_iter: int = 1000)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate the counterfactual scenario</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ge_method</code></strong> :&ensp;<code>str</code></dt>
<dd>(optional) The solver method to use for the full GE non-linear solver. See scipy.root()
documentation for option. Default is 'hybr'.</dd>
<dt><strong><code>ge_tolerance</code></strong> :&ensp;<code>float</code></dt>
<dd>(optional) The tolerance for determining if the GE system of equations is solved.
Default is 1e-8.</dd>
<dt><strong><code>ge_max_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>(optional) The maximum number of iterations allowed for the full GE nonlinear solver.
Default is 1000.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None
No return but populates new attributes of model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate(self, ge_method: str = &#39;hybr&#39;, ge_tolerance: float = 1e-8, ge_max_iter: int = 1000):
    &#39;&#39;&#39;
    Simulate the counterfactual scenario
    Args:
        ge_method (str): (optional) The solver method to use for the full GE non-linear solver. See scipy.root()
            documentation for option. Default is &#39;hybr&#39;.
        ge_tolerance (float): (optional) The tolerance for determining if the GE system of equations is solved.
            Default is 1e-8.
        ge_max_iter (int): (optional) The maximum number of iterations allowed for the full GE nonlinear solver.
            Default is 1000.

    Returns:
        None
            No return but populates new attributes of model.
    &#39;&#39;&#39;
    # &#39;&#39;&#39;
    # Simulate the counterfactual scenario.
    # :param ge_method: (str)
    # :param ge_tolerance: (float)
    #
    # :param ge_max_iter: (int)
    # :return: (None) No return but many fields in the model containing results are populated.
    # &#39;&#39;&#39;
    if not self._baseline_built:
        raise ValueError(&#34;Baseline must be built first (i.e. OneSectorGE.build_baseline() method&#34;)
    if not self._experiment_defined:
        raise ValueError(&#34;Expiriment must be defined first (i.e. OneSectorGE.define_expiriment() method&#34;)
    self._ge_method = ge_method
    self._ge_tolerance = ge_tolerance
    self._ge_max_iter = ge_max_iter
    # Step 1: Simulate conditional GE
    if self.approach == &#39;GEPPML&#39;:
        self._calculate_GEPPML_multilateral_resistance(version=&#39;conditional&#39;)
    else:
        self._calculate_multilateral_resistance(trade_costs=self.experiment_trade_costs, version=&#39;conditional&#39;)
    # Step 2: Simulate full GE
    self._calculate_full_ge()
    # Step 3: Generate post-simulation results
    [self.country_set[country]._construct_country_measures(sigma=self.sigma) for country in self.country_set.keys()]
    self._construct_experiment_output_expend()
    self._construct_experiment_trade()
    self._compile_results()</code></pre>
</details>
</dd>
<dt id="models.OneSectorGE.OneSectorGE.test_baseline_mr_function"><code class="name flex">
<span>def <span class="ident">test_baseline_mr_function</span></span>(<span>self, inputs_only: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Test whether the multilateral resistance system of equations can be computed from baseline data. Helpful for
debugging initial data problems. Note that the returned function values reflect those generated by the
initial values and do not reflect a solution to the system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inputs_only</code></strong> :&ensp;<code>bool</code></dt>
<dd>If False (default), the method tests the computability of the MR system of equations
and returns both the inputs to the system and the output. If True, only the system inputs are return and
the equations are not computed and can help diagnose input issues that raise errors.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing a collection of parameter and value inputs as well as the function
values at the initial values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_baseline_mr_function(self, inputs_only:bool=False):
    &#39;&#39;&#39;
    Test whether the multilateral resistance system of equations can be computed from baseline data. Helpful for
        debugging initial data problems. Note that the returned function values reflect those generated by the
        initial values and do not reflect a solution to the system.
    Args:
        inputs_only (bool): If False (default), the method tests the computability of the MR system of equations
            and returns both the inputs to the system and the output. If True, only the system inputs are return and
            the equations are not computed and can help diagnose input issues that raise errors.
    Returns:
        dict: A dictionary containing a collection of parameter and value inputs as well as the function
            values at the initial values.
    &#39;&#39;&#39;
    test_diagnostics = self._calculate_multilateral_resistance(trade_costs=self.baseline_trade_costs,
                                                               version=&#39;baseline&#39;, test=True,
                                                               inputs_only=inputs_only)
    return test_diagnostics</code></pre>
</details>
</dd>
<dt id="models.OneSectorGE.OneSectorGE.trade_share"><code class="name flex">
<span>def <span class="ident">trade_share</span></span>(<span>self, importers: List[str], exporters: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate baseline and experiment import and export shares (in percentages) between user-supplied countries.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>importers</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>A list of country codes to include as import partners.</dd>
<dt><strong><code>exporters</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>A list of country codes to include as export partners.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>A dataframe expressing baseline, experiment, and changes in trade between each specified importer and exporter.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trade_share(self, importers: List[str], exporters: List[str]):
    &#39;&#39;&#39;
    Calculate baseline and experiment import and export shares (in percentages) between user-supplied countries.
    Args:
        importers (list[str]): A list of country codes to include as import partners.
        exporters (list[str]): A list of country codes to include as export partners.

    Returns:
        pandas.DataFrame: A dataframe expressing baseline, experiment, and changes in trade between each specified importer and exporter.
    &#39;&#39;&#39;
    # &#39;&#39;&#39;
    #
    # :param importers:  A list of country codes to include as import partners.
    # :param exporters: (list[str]) A list of country codes to include as export partners.
    # :return: (DataFrame)
    # &#39;&#39;&#39;
    importer_col = self.meta_data.imp_var_name
    exporter_col = self.meta_data.exp_var_name
    bsln_modeled_trade_label = self.labels.baseline_modeled_trade
    exper_trade_label = self.labels.experiment_trade

    bilat_trade = self.bilateral_trade_results.reset_index()
    columns = [bsln_modeled_trade_label, exper_trade_label]
    imports = bilat_trade.loc[bilat_trade[importer_col].isin(importers), :].copy()
    exports = bilat_trade.loc[bilat_trade[&#39;exporter&#39;].isin(exporters), :].copy()

    total_imports = imports[columns].agg(&#39;sum&#39;)
    total_exports = exports[columns].agg(&#39;sum&#39;)

    selected_imports = imports.loc[imports[&#39;exporter&#39;].isin(exporters), columns].copy().agg(&#39;sum&#39;)
    selected_exports = exports.loc[exports[importer_col].isin(importers), columns].copy().agg(&#39;sum&#39;)

    import_data = 100 * selected_imports / total_imports
    export_data = 100 * selected_exports / total_exports

    import_data[&#39;description&#39;] = &#39;Percent of &#39; + &#34;, &#34;.join(importers) + &#39; imports from &#39; + &#34;, &#34;.join(exporters)
    export_data[&#39;description&#39;] = &#39;Percent of &#39; + &#34;, &#34;.join(exporters) + &#39; exports to &#39; + &#34;, &#34;.join(importers)

    both = pd.concat([import_data, export_data], axis=1).T
    both = both[[&#39;description&#39;] + columns]
    both[&#39;change (percentage point)&#39;] = (both[exper_trade_label] - both[bsln_modeled_trade_label])
    both[&#39;change (%)&#39;] = 100 * (both[exper_trade_label] - both[bsln_modeled_trade_label]) / \
                               both[bsln_modeled_trade_label]

    return both</code></pre>
</details>
</dd>
<dt id="models.OneSectorGE.OneSectorGE.trade_weighted_shock"><code class="name flex">
<span>def <span class="ident">trade_weighted_shock</span></span>(<span>self, how: str = 'country', aggregations: list = ['mean', 'sum', 'max'])</span>
</code></dt>
<dd>
<div class="desc"><p>Create measures of trade weighted policy shocks to better understand which countries are most affected. Results
reflect the absolute value of the change in trade costs multiplied by the</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>how</code></strong> :&ensp;<code>str</code></dt>
<dd>Determines the level of the results. If 'country', weighted shocks are returned at the country
level for both importer and exporter using specified methods of aggregation. If 'bilateral', it returns the
weighted shocks for all bilateral pairs. Default is 'country'.</dd>
<dt><strong><code>aggregations</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>A list of methods by which to aggregate weighted shocks if how = 'country'.
List entries must be selected from those that are functional with the pandas.DataFrame.agg() method. The
default value is ['mean', 'sum', 'max'].</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>A dataframe of trade-weighted trade cost shocks.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trade_weighted_shock(self, how:str = &#39;country&#39;, aggregations:list=[&#39;mean&#39;, &#39;sum&#39;, &#39;max&#39;]):
    &#39;&#39;&#39;
    Create measures of trade weighted policy shocks to better understand which countries are most affected. Results
    reflect the absolute value of the change in trade costs multiplied by the
    Args:
        how (str): Determines the level of the results. If &#39;country&#39;, weighted shocks are returned at the country
            level for both importer and exporter using specified methods of aggregation. If &#39;bilateral&#39;, it returns the
            weighted shocks for all bilateral pairs. Default is &#39;country&#39;.
        aggregations (list[str]):  A list of methods by which to aggregate weighted shocks if how = &#39;country&#39;.
            List entries must be selected from those that are functional with the pandas.DataFrame.agg() method. The
            default value is [&#39;mean&#39;, &#39;sum&#39;, &#39;max&#39;].
    Returns:
        pandas.DataFrame: A dataframe of trade-weighted trade cost shocks.
    &#39;&#39;&#39;
    # Collect needed results
    bilat_trade = self.bilateral_trade_results.copy()
    bilat_trade.reset_index(inplace=True)
    cost_shock = self.cost_shock.copy()

    # Define column names
    imp_col = self.meta_data.imp_var_name
    exp_col = self.meta_data.exp_var_name
    baseline_trade_col = self.labels.baseline_modeled_trade
    baseline_cost_col = &#39;baseline_trade_cost&#39;
    exper_cost_col = &#39;experiment_trade_cost&#39;
    cost_change = &#39;cost_change&#39;
    weighted_col = &#39;weighted_shock&#39;

    # Create change in costs and add to bilateral trade
    cost_shock[cost_change] = abs(cost_shock[exper_cost_col] - cost_shock[baseline_cost_col])
    trade_shock = bilat_trade.merge(cost_shock, how=&#39;left&#39;, on=[imp_col, exp_col])
    trade_shock = trade_shock[[exp_col, imp_col, baseline_trade_col, cost_change]]
    # Fill cases with no change in costs with zero
    trade_shock.fillna(0, inplace=True)
    # Calculate weighted costs and normalize my largest weighted shock
    trade_shock[weighted_col] = trade_shock[baseline_trade_col] * trade_shock[cost_change]
    max_shock = max(trade_shock[weighted_col])
    trade_shock[weighted_col] = trade_shock[weighted_col] / max_shock

    # Create aggregate measures at importer and exporter level
    exporter_shocks = trade_shock.groupby(exp_col).agg({weighted_col: aggregations})
    exporter_shocks.columns = pd.MultiIndex.from_product(exporter_shocks.columns.levels + [[exp_col]])
    importer_shocks = trade_shock.groupby(imp_col).agg({weighted_col: aggregations})
    importer_shocks.columns = pd.MultiIndex.from_product(importer_shocks.columns.levels + [[imp_col]])
    weighted_shocks = pd.concat([exporter_shocks, importer_shocks], axis=1)

    if how == &#39;country&#39;:
        return weighted_shocks
    if how == &#39;bilateral&#39;:
        return trade_shock</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="models.OneSectorGE.ParameterValues"><code class="flex name class">
<span>class <span class="ident">ParameterValues</span></span>
<span>(</span><span>estimates: pandas.core.frame.DataFrame, identifier_col: str, coeff_col: str, stderr_col: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Object for supplying non-gme.EstimationModel estimates such as those from Stata, R, the literature, or any other
source of gravity estimates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>estimates</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>A dataframe containing gravity model estimates, which ought to include the
following non-optional columns.</dd>
<dt><strong><code>identifier_col</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the column containing the identifiers for each estimate. These should
correspond to the cost variables that you will use for trade costs in the simulation. This column is
required.</dd>
<dt><strong><code>coeff_col</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the column containing the coefficient estimates for each variable. They
should be numeric and are required.</dd>
<dt><strong><code>stderr_col</code></strong> :&ensp;<code>str</code></dt>
<dd>The column name for the standard error estimates for each variable. This column is only
required for the MonteCarloGE model and may be omitted for the OneSectorGE model.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="models.OneSectorGE.ParameterValues" href="#models.OneSectorGE.ParameterValues">ParameterValues</a></code></dt>
<dd>An instance of a ParameterValues object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterValues(object):
    def __init__(self,
             estimates:DataFrame,
                 identifier_col: str,
                 coeff_col:str,
                 stderr_col:str = None):
                 #imp_fe_prefix: str = None, # Removed until completeion of GEPPML
                 #exp_fe_prefix: str = None # Removed until completeion of GEPPML

        &#39;&#39;&#39;
        Object for supplying non-gme.EstimationModel estimates such as those from Stata, R, the literature, or any other
        source of gravity estimates.
        Args:
            estimates (pandas.DataFrame): A dataframe containing gravity model estimates, which ought to include the
                following non-optional columns.
            identifier_col (str): The name of the column containing the identifiers for each estimate. These should
                correspond to the cost variables that you will use for trade costs in the simulation. This column is
                required.
            coeff_col (str): The name of the column containing the coefficient estimates for each variable. They
                should be numeric and are required.
            stderr_col (str):  The column name for the standard error estimates for each variable. This column is only
                required for the MonteCarloGE model and may be omitted for the OneSectorGE model.

        Returns:
            ParameterValues: An instance of a ParameterValues object.
        &#39;&#39;&#39;
        # &#39;&#39;&#39;
        # imp_fe_prefix (str):  The prefix used to identify the importer fixed effects. These fixed effects and
        #         prefix are only required for the GEPPML approach in OneSectorGE.
        #     exp_fe_prefix (str):  The prefix used to identify the exporter fixed effects. These fixed effects and
        #         prefix are only required for the GEPPML approach in OneSectorGE.
        # &#39;&#39;&#39;
        estimates = estimates.set_index(identifier_col)
        # Coefficient  Estimates
        self.params = estimates[coeff_col].copy()
        # Standard error estimates
        if stderr_col is not None:
            self.bse = estimates[stderr_col].copy()
        else:
            self.bse = None</code></pre>
</details>
</dd>
<dt id="models.OneSectorGE.ResultsLabels"><code class="flex name class">
<span>class <span class="ident">ResultsLabels</span></span>
</code></dt>
<dd>
<div class="desc"><p>Labels and definitions used in results outputs:</p>
<pre><code># Bilateral Trade Results
</code></pre>
<p><strong>baseline modeled trade</strong>: Trade constructed using estimated baseline trade costs and multilateral
resistances (X_{ij}).</p>
<p><strong>experiment trade</strong>: Counterfactual experiment trade constructed using experiment trade costs and GE
experiment multilateral resistances (X'_{ij}).</p>
<p><strong>trade change (percent)</strong>: Estimated percent change in bilateral trade (100*[X'_{ij} - X_{ij}]/X_{ij})</p>
<p><strong>trade change (observed level)</strong>: Estimated change in trade values using observed trade in the source
sample. (i.e. estimated trade change times observed values)</p>
<p><strong>baseline observed trade</strong>: Observed trade values. (Not necessarily equivalent to modeled values.)</p>
<p><strong>experiment observed trade</strong>: Estiamted counterfactual trade values based on predicted change and observed
baseline values. (Not necessarily equivalent to modeled values.)</p>
<pre><code># Country level Results
</code></pre>
<p><strong>country</strong>: Country identifier.</p>
<p><strong>factory gate price change (percent)</strong>: Estimated percent change in factory gate prices.</p>
<p><strong>experiment factory gate price</strong>: Experiment factory gate prices (P_i). Baseline prices are all set to 1.</p>
<p><strong>terms of trade change (percent)</strong>: Percent change in the terms of trade. Terms of trade defined as factory
gate price (p_i) divided by inward multilateral resistance (P_i). Measures changes in output prices relative
to consumption prices. Increases imply greater purchasing power (income growth relative to consumption
costs), decreases imply lower purchasing power.</p>
<p><strong>GDP change (percent)</strong>: Percent change in GDP, which is calculated as output (Y_i) divided by factory gate
prices (p_i)</p>
<p><strong>welfare statistic</strong>: Welfare statistic form Arkolakis et al. (2012) and Yotov et al. (2016). Defined as
(E_i/P_i)/(E'_i/P'_i) where E_i denotes expenditure, P_i denotes inward multilateral resistance, and ' denotes
the experiment estimates.</p>
<p><strong>baseline output</strong>: User supplied baseline output (Y_i).</p>
<p><strong>experiment output</strong>: Experiment estimated output (Y'_i).</p>
<p><strong>output change (percent)</strong>: Estimated percent change in output (100*[Y'_i - Y_i]/Y_i).</p>
<p><strong>baseline expenditure</strong>: User supplied baseline expenditure (E_i).</p>
<p><strong>experiment expenditure</strong>: Experiment estimated expenditure (E'_i).</p>
<p><strong>expenditure change (percent)</strong>: Estimated percent change in expenditure (100*[E'_i - E_i]/E_i).</p>
<p><strong>baseline modeled shipments</strong>: Modeled baseline aggregate exports including both domestic and international
flows (S_i = sum_j X_{ij} for all j).</p>
<p><strong>experiment shipments</strong>: Estimated experiment aggregate exports including both domestic and international
flows (S'_i = sum_j X'_{ij} for all j).</p>
<p><strong>shipments change (percent)</strong>: Estimated percent change in total shipments (100*[S'_i -
S_i]/S_i)</p>
<p><strong>baseline modeled consumption</strong>: Modeled baseline aggregate imports including both intranational and
international flows (C_j = sum_i X_{ij} for all i).</p>
<p><strong>experiment consumption</strong>: Estimated experiment aggregate imports including both intranational and
international flows (C'_j = sum_i X'_{ij} for all i).</p>
<p><strong>consumption change (percent)</strong>: Estimated percent change in total consumption
(100*[C'_j - C_j]/C_j)</p>
<p><strong>baseline modeled foreign exports</strong>: Modeled baseline aggregate exports, international flows only.
(X_i = sum_j X_{ij} for all j!=i)</p>
<p><strong>experiment foreign exports</strong>: Estimated experiment aggregate exports, international flows only.
(X'_i = sum_j X'_{ij} for all j!=i)</p>
<p><strong>foreign exports change (percent)</strong>: Estimated percent change in aggregate foreign exports (100*[X'_i - X_i]
/X_i).</p>
<p><strong>baseline observed foreign exports</strong>: Total foreign exports based on observed rather than modeled baseline
values.</p>
<p><strong>baseline modeled foreign imports</strong>: Modeled baseline aggregate imports, international flows only.
(X_j = sum_i X_{ij} for all i!=j)</p>
<p><strong>experiment foreign imports</strong>: Estimated experiment aggregate imports, international flows only.
(X_j = sum_i X_{ij} for all i!=j)</p>
<p><strong>foreign imports change (percent)</strong>: Estimated percent change in aggregate foreign imports (100*[X'_j - X_j]
/X_j).</p>
<p><strong>baseline observed foreign imports</strong>: Total foreign imports based on observed rather than modeled baseline
values.</p>
<p><strong>baseline modeled intranational trade</strong>: Modeled baseline intranational (domestic) trade flows (X_{ii}).</p>
<p><strong>experiment modeled intranational trade</strong>: Estimated experiment intranational (domestic) trade flows
(X'_{ii}).</p>
<p><strong>intranational trade change (percent)</strong>: Estimated percent change in intranational (domestic) trade flows
(100*[X'_{ii} - X_{ii}]/X_{ii})</p>
<p><strong>baseline observed intranational trade</strong>: Intranational trade flows based on observed values rather than
modeled baseline values.</p>
<p><strong>baseline imr</strong>: Baseline constructed inward multilateral resistance terms (P_j). P_j = 1 for the selected
reference importer.</p>
<p><strong>conditional imr</strong>: Partial equilibrium ('conditional') estimates of the inward multilateral resistance
terms.</p>
<p><strong>experiment imr</strong>: Full equilibrium estimates for the counterfactual experiment inward multilateral
resistance terms (P'_j). P'_j = 1 for the selected reference importer.</p>
<p><strong>imr change (percent)</strong>: Estimated percent change in inward multilateral resistances
(100*[P'_j - P_j]/P_j).</p>
<p><strong>baseline omr</strong>: Baseline constructed outward multilateral resistance terms (π_i).</p>
<p><strong>conditional omr</strong>: Partial equilibrium ('conditional') estimates of the outward multilateral resistance
terms.</p>
<p><strong>experiment omr</strong>: Full equilibrium estimates for the counterfactual experiment outward multilateral
resistance terms (π'_i).</p>
<p><strong>omr change (percent)</strong>: Estimated percent change in outward multilateral resistances
(100*[π'_i - π_i]/π_i).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResultsLabels(object):
    &#34;&#34;&#34;
    Labels and definitions used in results outputs:

    # Bilateral Trade Results

        \n **baseline modeled trade**: Trade constructed using estimated baseline trade costs and multilateral
            resistances (X\_{ij}).
        \n**experiment trade**: Counterfactual experiment trade constructed using experiment trade costs and GE
        experiment multilateral resistances (X&#39;\_{ij}).
        \n**trade change (percent)**: Estimated percent change in bilateral trade (100*[X&#39;\_{ij} - X\_{ij}]/X\_{ij})
        \n**trade change (observed level)**: Estimated change in trade values using observed trade in the source
        sample. (i.e. estimated trade change times observed values)
        \n**baseline observed trade**: Observed trade values. (Not necessarily equivalent to modeled values.)
        \n**experiment observed trade**: Estiamted counterfactual trade values based on predicted change and observed
        baseline values. (Not necessarily equivalent to modeled values.)

    # Country level Results
        \n **country**: Country identifier.
        \n **factory gate price change (percent)**: Estimated percent change in factory gate prices.
        \n **experiment factory gate price**: Experiment factory gate prices (P_i). Baseline prices are all set to 1.
        \n **terms of trade change (percent)**: Percent change in the terms of trade. Terms of trade defined as factory
            gate price (p_i) divided by inward multilateral resistance (P_i). Measures changes in output prices relative
            to consumption prices. Increases imply greater purchasing power (income growth relative to consumption
            costs), decreases imply lower purchasing power.
        \n **GDP change (percent)**: Percent change in GDP, which is calculated as output (Y_i) divided by factory gate
            prices (p_i)
        \n **welfare statistic**: Welfare statistic form Arkolakis et al. (2012) and Yotov et al. (2016). Defined as
            (E_i/P_i)/(E&#39;_i/P&#39;_i) where E_i denotes expenditure, P_i denotes inward multilateral resistance, and &#39; denotes
            the experiment estimates.
        \n **baseline output**: User supplied baseline output (Y_i).
        \n **experiment output**: Experiment estimated output (Y&#39;_i).
        \n **output change (percent)**: Estimated percent change in output (100*[Y&#39;_i - Y_i]/Y_i).
        \n **baseline expenditure**: User supplied baseline expenditure (E_i).
        \n **experiment expenditure**: Experiment estimated expenditure (E&#39;_i).
        \n **expenditure change (percent)**: Estimated percent change in expenditure (100*[E&#39;_i - E_i]/E_i).
        \n **baseline modeled shipments**: Modeled baseline aggregate exports including both domestic and international
            flows (S_i = sum_j X_{ij} for all j).
        \n **experiment shipments**: Estimated experiment aggregate exports including both domestic and international
            flows (S&#39;_i = sum_j X&#39;\_{ij} for all j).
        \n **shipments change (percent)**: Estimated percent change in total shipments (100*[S&#39;_i -
            S_i]/S_i)
        \n **baseline modeled consumption**: Modeled baseline aggregate imports including both intranational and
            international flows (C_j = sum_i X_{ij} for all i).
        \n **experiment consumption**: Estimated experiment aggregate imports including both intranational and
            international flows (C&#39;\_j = sum_i X&#39;_{ij} for all i).
        \n **consumption change (percent)**: Estimated percent change in total consumption
            (100*[C&#39;_j - C_j]/C_j)
        \n **baseline modeled foreign exports**: Modeled baseline aggregate exports, international flows only.
            (X_i = sum_j X_{ij} for all j!=i)
        \n **experiment foreign exports**: Estimated experiment aggregate exports, international flows only.
            (X&#39;_i = sum_j X&#39;\_{ij} for all j!=i)
        \n **foreign exports change (percent)**: Estimated percent change in aggregate foreign exports (100*[X&#39;_i - X_i]
            /X_i).
        \n **baseline observed foreign exports**: Total foreign exports based on observed rather than modeled baseline
            values.
        \n **baseline modeled foreign imports**: Modeled baseline aggregate imports, international flows only.
            (X_j = sum_i X_{ij} for all i!=j)
        \n **experiment foreign imports**: Estimated experiment aggregate imports, international flows only.
            (X_j = sum_i X_{ij} for all i!=j)
        \n **foreign imports change (percent)**: Estimated percent change in aggregate foreign imports (100*[X&#39;_j - X_j]
            /X_j).
        \n **baseline observed foreign imports**: Total foreign imports based on observed rather than modeled baseline
            values.
        \n **baseline modeled intranational trade**: Modeled baseline intranational (domestic) trade flows (X_{ii}).
        \n **experiment modeled intranational trade**: Estimated experiment intranational (domestic) trade flows
            (X&#39;\_{ii}).
        \n **intranational trade change (percent)**: Estimated percent change in intranational (domestic) trade flows
            (100*[X&#39;\_{ii} - X_{ii}]/X_{ii})
        \n **baseline observed intranational trade**: Intranational trade flows based on observed values rather than
            modeled baseline values.
        \n **baseline imr**: Baseline constructed inward multilateral resistance terms (P_j). P_j = 1 for the selected
            reference importer.
        \n **conditional imr**: Partial equilibrium (&#39;conditional&#39;) estimates of the inward multilateral resistance
            terms.
        \n **experiment imr**: Full equilibrium estimates for the counterfactual experiment inward multilateral
            resistance terms (P&#39;\_j). P&#39;\_j = 1 for the selected reference importer.
        \n **imr change (percent)**: Estimated percent change in inward multilateral resistances
            (100*[P&#39;\_j - P_j]/P_j).
        \n **baseline omr**: Baseline constructed outward multilateral resistance terms (π_i).
        \n **conditional omr**: Partial equilibrium (&#39;conditional&#39;) estimates of the outward multilateral resistance
            terms.
        \n **experiment omr**: Full equilibrium estimates for the counterfactual experiment outward multilateral
            resistance terms (π&#39;\_i).
        \n **omr change (percent)**: Estimated percent change in outward multilateral resistances
            (100*[π&#39;\_i - π_i]/π_i).

    &#34;&#34;&#34;
    def __init__(self):
        # Trade Labels (bilateral)
        self.baseline_modeled_trade = &#39;baseline modeled trade&#39;
        self.experiment_trade = &#39;experiment trade&#39;
        self.trade_change = &#39;trade change (percent)&#39;
        self.trade_change_level = &#39;trade change (observed level)&#39;
        self.baseline_observed_trade = &#39;baseline observed trade&#39;
        self.experiment_observed_trade = &#39;experiment observed trade&#39;

        # Country level
        self.identifier= &#39;country&#39;
        self.factory_price_change= &#39;factory gate price change (percent)&#39;
        self.experiment_factory_price= &#39;experiment factory gate price&#39;
        self.terms_of_trade_change = &#39;terms of trade change (percent)&#39;
        self.gdp_change = &#34;GDP change (percent)&#34;
        self.welfare_stat = &#39;welfare statistic&#39;
        self.baseline_output = &#39;baseline output&#39;
        self.experiment_output = &#39;experiment output&#39;
        self.output_change = &#39;output change (percent)&#39;
        self.baseline_expenditure = &#39;baseline expenditure&#39;
        self.experiment_expenditure = &#39;experiment expenditure&#39;
        self.expenditure_change = &#39;expenditure change (percent)&#39;
        self.baseline_exports = &#39;baseline modeled shipments&#39;
        self.experiment_exports = &#39;experiment shipments&#39;
        self.exports_change = &#39;shipments change (percent)&#39;
        self.baseline_imports = &#39;baseline modeled consumption&#39;
        self.experiment_imports = &#39;experiment consumption&#39;
        self.imports_change = &#39;consumption change (percent)&#39;
        self.baseline_foreign_exports = &#39;baseline modeled foreign exports&#39;
        self.experiment_foreign_exports = &#39;experiment foreign exports&#39;
        self.foreign_exports_change = &#39;foreign exports change (percent)&#39;
        self.baseline_observed_foreign_exports = &#39;baseline observed foreign exports&#39;
        self.baseline_foreign_imports = &#39;baseline modeled foreign imports&#39;
        self.experiment_foreign_imports = &#39;experiment foreign imports&#39;
        self.foreign_imports_change = &#39;foreign imports change (percent)&#39;
        self.baseline_observed_foreign_imports = &#39;baseline observed foreign imports&#39;
        self.baseline_intranational_trade = &#39;baseline modeled intranational trade&#39;
        self.experiment_intranational_trade = &#39;experiment modeled intranational trade&#39;
        self.intranational_trade_change = &#39;intranational trade change (percent)&#39;
        self.baseline_observed_intranational_trade = &#39;baseline observed intranational trade&#39;
        self.baseline_imr = &#39;baseline imr&#39;
        self.conditional_imr = &#39;conditional imr&#39;
        self.experiment_imr = &#39;experiment imr&#39;
        self.imr_change = &#39;imr change (percent)&#39;
        self.baseline_omr = &#39;baseline omr&#39;
        self.conditional_omr = &#39;conditional omr&#39;
        self.experiment_omr = &#39;experiment omr&#39;
        self.omr_change = &#39;omr change (percent)&#39;

        # Get a set of country-level results by excluding the bilateral ones
        self.bilat_labels = [self.baseline_modeled_trade, self.experiment_trade, self.trade_change,
                             self.trade_change_level, self.baseline_observed_trade, self.experiment_observed_trade]

        # Create a list of Country-level labels to include in results
        self.country_level_labels = [self.identifier,
                        self.factory_price_change,
                        self.baseline_imr, self.experiment_imr, self.imr_change,
                        self.baseline_omr, self.experiment_omr, self.omr_change,
                        self.terms_of_trade_change, self.gdp_change, self.welfare_stat,
                        self.baseline_output, self.experiment_output, self.output_change,
                        self.baseline_expenditure, self.experiment_expenditure, self.expenditure_change,
                        self.baseline_foreign_exports, self.experiment_foreign_exports,
                        self.foreign_exports_change, self.baseline_observed_foreign_exports,
                        self.baseline_foreign_imports, self.experiment_foreign_imports,
                        self.foreign_imports_change, self.baseline_observed_foreign_imports,
                        self.baseline_intranational_trade, self.experiment_intranational_trade,
                        self.intranational_trade_change, self.baseline_observed_intranational_trade]</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="models" href="index.html">models</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="models.OneSectorGE.Country" href="#models.OneSectorGE.Country">Country</a></code></h4>
<ul class="">
<li><code><a title="models.OneSectorGE.Country.get_mr_results" href="#models.OneSectorGE.Country.get_mr_results">get_mr_results</a></code></li>
<li><code><a title="models.OneSectorGE.Country.get_results" href="#models.OneSectorGE.Country.get_results">get_results</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="models.OneSectorGE.Economy" href="#models.OneSectorGE.Economy">Economy</a></code></h4>
</li>
<li>
<h4><code><a title="models.OneSectorGE.OneSectorGE" href="#models.OneSectorGE.OneSectorGE">OneSectorGE</a></code></h4>
<ul class="">
<li><code><a title="models.OneSectorGE.OneSectorGE.build_baseline" href="#models.OneSectorGE.OneSectorGE.build_baseline">build_baseline</a></code></li>
<li><code><a title="models.OneSectorGE.OneSectorGE.calculate_levels" href="#models.OneSectorGE.OneSectorGE.calculate_levels">calculate_levels</a></code></li>
<li><code><a title="models.OneSectorGE.OneSectorGE.check_omr_rescale" href="#models.OneSectorGE.OneSectorGE.check_omr_rescale">check_omr_rescale</a></code></li>
<li><code><a title="models.OneSectorGE.OneSectorGE.define_experiment" href="#models.OneSectorGE.OneSectorGE.define_experiment">define_experiment</a></code></li>
<li><code><a title="models.OneSectorGE.OneSectorGE.export_results" href="#models.OneSectorGE.OneSectorGE.export_results">export_results</a></code></li>
<li><code><a title="models.OneSectorGE.OneSectorGE.simulate" href="#models.OneSectorGE.OneSectorGE.simulate">simulate</a></code></li>
<li><code><a title="models.OneSectorGE.OneSectorGE.test_baseline_mr_function" href="#models.OneSectorGE.OneSectorGE.test_baseline_mr_function">test_baseline_mr_function</a></code></li>
<li><code><a title="models.OneSectorGE.OneSectorGE.trade_share" href="#models.OneSectorGE.OneSectorGE.trade_share">trade_share</a></code></li>
<li><code><a title="models.OneSectorGE.OneSectorGE.trade_weighted_shock" href="#models.OneSectorGE.OneSectorGE.trade_weighted_shock">trade_weighted_shock</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="models.OneSectorGE.ParameterValues" href="#models.OneSectorGE.ParameterValues">ParameterValues</a></code></h4>
</li>
<li>
<h4><code><a title="models.OneSectorGE.ResultsLabels" href="#models.OneSectorGE.ResultsLabels">ResultsLabels</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>